<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">

<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.6.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.6.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="由上两篇Redis源码阅读笔记-命令的接收和执行过程(一) 和Redis源码阅读笔记-命令的接收和执行过程(二) 可以知道，大部分命令是从server.c文件中的int processCommand(client *c)函数，通过lookupCommand()获的结构体为redisCommand的命令的。其实这是通过命令名在server.commands中来查看的。 Redis的命令列表是保存在全">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码阅读笔记-各命令的执行(编写中)">
<meta property="og:url" content="http://yoursite.com/2019/05/26/Redis源码阅读笔记-各命令的执行/index.html">
<meta property="og:site_name" content="Ming Blog">
<meta property="og:description" content="由上两篇Redis源码阅读笔记-命令的接收和执行过程(一) 和Redis源码阅读笔记-命令的接收和执行过程(二) 可以知道，大部分命令是从server.c文件中的int processCommand(client *c)函数，通过lookupCommand()获的结构体为redisCommand的命令的。其实这是通过命令名在server.commands中来查看的。 Redis的命令列表是保存在全">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-26T15:05:05.508Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码阅读笔记-各命令的执行(编写中)">
<meta name="twitter:description" content="由上两篇Redis源码阅读笔记-命令的接收和执行过程(一) 和Redis源码阅读笔记-命令的接收和执行过程(二) 可以知道，大部分命令是从server.c文件中的int processCommand(client *c)函数，通过lookupCommand()获的结构体为redisCommand的命令的。其实这是通过命令名在server.commands中来查看的。 Redis的命令列表是保存在全">






  <link rel="canonical" href="http://yoursite.com/2019/05/26/Redis源码阅读笔记-各命令的执行/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Redis源码阅读笔记-各命令的执行(编写中) | Ming Blog</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ming Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Ming的博客</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/26/Redis源码阅读笔记-各命令的执行/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ming">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ming Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis源码阅读笔记-各命令的执行(编写中)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-26 23:05:00 / 修改时间：23:05:05" itemprop="dateCreated datePublished" datetime="2019-05-26T23:05:00+08:00">2019-05-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Redis/阅读笔记/" itemprop="url" rel="index"><span itemprop="name">阅读笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>由上两篇<a href="http://blog.mingforpc.me/2018/12/20/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-%E4%B8%80/" target="_blank" rel="noopener">Redis源码阅读笔记-命令的接收和执行过程(一)
</a>和<a href="http://blog.mingforpc.me/2019/01/08/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8E%A5%E6%94%B6%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B-%E4%BA%8C/" target="_blank" rel="noopener">Redis源码阅读笔记-命令的接收和执行过程(二)
</a>可以知道，大部分命令是从<code>server.c</code>文件中的<code>int processCommand(client *c)</code>函数，通过<code>lookupCommand()</code>获的结构体为<code>redisCommand</code>的命令的。其实这是通过命令名在<code>server.commands</code>中来查看的。</p>
<p>Redis的命令列表是保存在全局变量<code>server.commands</code>中的，而其初始化是在</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServerConfig</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">	server.commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">	server.orig_commands = dictCreate(&amp;commandTableDictType,<span class="literal">NULL</span>);</span><br><span class="line">	populateCommandTable();</span><br><span class="line">	server.delCommand = lookupCommandByCString(<span class="string">"del"</span>);</span><br><span class="line">	server.multiCommand = lookupCommandByCString(<span class="string">"multi"</span>);</span><br><span class="line">	server.lpushCommand = lookupCommandByCString(<span class="string">"lpush"</span>);</span><br><span class="line">	server.lpopCommand = lookupCommandByCString(<span class="string">"lpop"</span>);</span><br><span class="line">	server.rpopCommand = lookupCommandByCString(<span class="string">"rpop"</span>);</span><br><span class="line">	server.sremCommand = lookupCommandByCString(<span class="string">"srem"</span>);</span><br><span class="line">	server.execCommand = lookupCommandByCString(<span class="string">"exec"</span>);</span><br><span class="line">	server.expireCommand = lookupCommandByCString(<span class="string">"expire"</span>);</span><br><span class="line">	server.pexpireCommand = lookupCommandByCString(<span class="string">"pexpire"</span>);</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而其中，<code>populateCommandTable()</code>是给<code>server.commands</code>和<code>server.orig_commands</code>初始化值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="comment">/* Populates the Redis Command Table starting from the hard coded list</span></span><br><span class="line"><span class="comment"> * we have on top of redis.c file. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populateCommandTable</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> numcommands = <span class="keyword">sizeof</span>(redisCommandTable)/<span class="keyword">sizeof</span>(struct redisCommand);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numcommands; j++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">c</span> = <span class="title">redisCommandTable</span>+<span class="title">j</span>;</span></span><br><span class="line">        <span class="keyword">char</span> *f = c-&gt;sflags;</span><br><span class="line">        <span class="keyword">int</span> retval1, retval2;</span><br><span class="line">		 </span><br><span class="line">		 <span class="comment">// 区分命令的类型</span></span><br><span class="line">        <span class="keyword">while</span>(*f != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span>(*f) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'w'</span>: c-&gt;flags |= CMD_WRITE; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'r'</span>: c-&gt;flags |= CMD_READONLY; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'m'</span>: c-&gt;flags |= CMD_DENYOOM; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>: c-&gt;flags |= CMD_ADMIN; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'p'</span>: c-&gt;flags |= CMD_PUBSUB; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>: c-&gt;flags |= CMD_NOSCRIPT; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>: c-&gt;flags |= CMD_RANDOM; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>: c-&gt;flags |= CMD_SORT_FOR_SCRIPT; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'l'</span>: c-&gt;flags |= CMD_LOADING; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>: c-&gt;flags |= CMD_STALE; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: c-&gt;flags |= CMD_SKIP_MONITOR; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'k'</span>: c-&gt;flags |= CMD_ASKING; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>: c-&gt;flags |= CMD_FAST; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: serverPanic(<span class="string">"Unsupported command flag"</span>); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            f++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval1 = dictAdd(server.commands, sdsnew(c-&gt;name), c);</span><br><span class="line">        <span class="comment">/* Populate an additional dictionary that will be unaffected</span></span><br><span class="line"><span class="comment">         * by rename-command statements in redis.conf. */</span></span><br><span class="line">        retval2 = dictAdd(server.orig_commands, sdsnew(c-&gt;name), c);</span><br><span class="line">        serverAssert(retval1 == DICT_OK &amp;&amp; retval2 == DICT_OK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 <code>redisCommandTable</code>则是在<code>server.c</code>文件中的一个全局变量，保存着命令字符串和操作函数。</p>
<h2 id="redisCommand结构体"><a href="#redisCommand结构体" class="headerlink" title="redisCommand结构体"></a><code>redisCommand</code>结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//server.h </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags; <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * Used for Redis Cluster redirect. */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>: 是命令的名字。</li>
<li><code>proc</code>: 是命令的操作函数的指针，指向这个命令的具体操作。</li>
<li><code>arity</code>: 命令所需参数的数量。</li>
<li><code>sflags</code>: 命令标识的字符串形式。<ul>
<li><code>w</code>: 写命令。</li>
<li><code>r</code>: 读命令。</li>
<li><code>m</code>: 当调用时可能会增加内存的使用。（当超过内存限制时不允许执行）</li>
<li><code>a</code>: 管理员权限的命令，etc: <code>SAVE</code>和<code>SHUTDOWN</code>。</li>
<li><code>p</code>: <code>Pub/Sub</code>相关的命令。</li>
<li><code>f</code>: 无论<code>server.dirty</code>的值如何，都强制执行。</li>
<li><code>s</code>: 不允许在Lua脚本中执行此函数。</li>
<li><code>R</code>: 随机类型的命令，这表示命令是不幂等的。意思是，同一个命令，具有相同的参数和键空间，可能会有不同的结果。比如<code>SPOP</code>和<code>RANDOMKEY</code>。</li>
<li><code>S</code>: 表示如果命令从脚本调用，会将输出的数组排序，使得结果具有幂等性。</li>
<li><code>l</code>: 表示允许该命令在加载数据库时执行。</li>
<li><code>t</code>: 表示允许命令在“从”服务器中有过时数据时执行。这个命令类型是很少的。</li>
<li><code>M</code>: 表示命令不会自动在MONITOR上传播。</li>
<li><code>k</code>: 表示会对该命令隐式得执行<code>ASKING</code>这会使得在集群模式下，slot会被标记为<code>importing</code>。</li>
<li><code>F</code>: 快速执行的命令（一般是时间复杂度为<code>O(n)</code>和<code>O(log(n))</code>的命令）。只要内核调度给予时间则都不应该被延迟执行。PS：对于<code>SET</code>来说，由于可能会触发<code>DEL</code>命令，所以不是快速命令。</li>
</ul>
</li>
<li><code>flags</code>: 命令表示的比特位形式。</li>
<li><code>getkeys_proc</code>: 指向一个帮助在命令行中获取”键”参数的函数。（可选的，仅当下面3个参数不足以指定哪些是“键”）。</li>
<li><code>firstkey</code>: 表明第一个参数是“键”。</li>
<li><code>lastkey</code>: 表明最后一个参数是”键”。</li>
<li><code>keystep</code>: “键”参数的间隔数，比如<code>MSET</code>中参数形式为<code>key, val, key, val</code>。</li>
</ul>
<h2 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h2><h3 id="MODULE模块化命令"><a href="#MODULE模块化命令" class="headerlink" title="MODULE模块化命令"></a><code>MODULE</code>模块化命令</h3><p>Reids 4.0 中加入的功能，可以通过外部模块对Redis进行功能扩展。</p>
<ul>
<li><code>sflags</code>：<code>as</code>，表示其为管理员权限的命令，而且不允许被Lua脚本调用。</li>
</ul>
<h4 id="命令形式"><a href="#命令形式" class="headerlink" title="命令形式"></a>命令形式</h4><ul>
<li><code>MODULE LOAD /path/to/mymodule.so</code>表示加载模块。</li>
<li><code>MODULE LIST</code>表示列出已经加载的模块。</li>
<li><code>MODULE UNLOAD mymodule</code>表示卸载模块。</li>
</ul>
<h4 id="内部实现函数"><a href="#内部实现函数" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>打算迟点写一下module模块的实现，所以更详细的迟点再写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Redis MODULE command.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MODULE LOAD &lt;path&gt; [args...] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moduleCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *subcmd = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"load"</span>) &amp;&amp; c-&gt;argc &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 `MODULE LOAD /path/to/mymodule.so`</span></span><br><span class="line">        robj **argv = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            argc = c-&gt;argc - <span class="number">3</span>;</span><br><span class="line">            argv = &amp;c-&gt;argv[<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正加载模块的函数，该函数工作顺序:</span></span><br><span class="line">        <span class="comment">// 1. 通过`dlopen()`加载动态链接库</span></span><br><span class="line">        <span class="comment">// 2. 通过`dlsym()`获得 RedisModule_OnLoad 的加载函数 onload</span></span><br><span class="line">        <span class="comment">// 3. 调用 onload 加载</span></span><br><span class="line">        <span class="comment">// 4. 加载成功，以模块名字为Key，保存入全局字典变量modules中</span></span><br><span class="line">        <span class="keyword">if</span> (moduleLoad(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,(<span class="keyword">void</span> **)argv,argc) == C_OK)</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyError(c,</span><br><span class="line">                <span class="string">"Error loading the extension. Please check the server logs."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"unload"</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用 `MODULE UNLOAD mymodule`</span></span><br><span class="line">        <span class="comment">// 真正卸载模块的函数，该函数工作顺序:</span></span><br><span class="line">        <span class="comment">// 1. 在注销模块注册的命令</span></span><br><span class="line">        <span class="comment">// 2. 注销所有此模块的消息订阅</span></span><br><span class="line">        <span class="comment">// 3. 通过`dlclose()`卸载模块</span></span><br><span class="line">        <span class="comment">// 4. 在全局字典变量modules删除模块</span></span><br><span class="line">        <span class="keyword">if</span> (moduleUnload(c-&gt;argv[<span class="number">2</span>]-&gt;ptr) == C_OK)</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> *errmsg;</span><br><span class="line">            <span class="keyword">switch</span>(errno) &#123;</span><br><span class="line">            <span class="keyword">case</span> ENOENT:</span><br><span class="line">                errmsg = <span class="string">"no such module with that name"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EBUSY:</span><br><span class="line">                errmsg = <span class="string">"the module exports one or more module-side data types, can't unload"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                errmsg = <span class="string">"operation not possible."</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">"Error unloading module: %s"</span>,errmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"list"</span>) &amp;&amp; c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用`MODULE LIST`</span></span><br><span class="line">        dictIterator *di = dictGetIterator(modules);</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历全局字典表量modules, 获得其中的模块名</span></span><br><span class="line">        addReplyMultiBulkLen(c,dictSize(modules));</span><br><span class="line">        <span class="keyword">while</span> ((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds name = dictGetKey(de);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">RedisModule</span> *<span class="title">module</span> = <span class="title">dictGetVal</span>(<span class="title">de</span>);</span></span><br><span class="line">            addReplyMultiBulkLen(c,<span class="number">4</span>);</span><br><span class="line">            addReplyBulkCString(c,<span class="string">"name"</span>);</span><br><span class="line">            addReplyBulkCBuffer(c,name,sdslen(name));</span><br><span class="line">            addReplyBulkCString(c,<span class="string">"ver"</span>);</span><br><span class="line">            addReplyLongLong(c,<span class="keyword">module</span>-&gt;ver);</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GET命令"><a href="#GET命令" class="headerlink" title="GET命令"></a><code>GET</code>命令</h3><p>返回与键 <code>key</code> 相关联的字符串值。</p>
<p>如果键<code>key</code>不存在，那么返回特殊值<code>nil</code>；否则，返回键<code>key</code>的值。</p>
<p>如果键<code>key</code>的值并非字符串类型，那么返回一个错误，因为<code>GET</code>命令只能用于字符串值。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>，表示是读命令，且快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-1"><a href="#命令形式-1" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#123;key name&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-1"><a href="#内部实现函数-1" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGenericCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// c-&gt;argv[1]为命令中的 key，`shared.nullbulk`是返回的默认值 `nil`</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 判断返回的值得格式，只允许字符串格式</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyReadOrReply</span><span class="params">(client *c, robj *key, robj *reply)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyRead(c-&gt;db, key);</span><br><span class="line">    <span class="keyword">if</span> (!o) addReply(c,reply);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用流程:</p>
<ol>
<li><code>getCommand()</code>在函数内调用<code>getGenericCommand()</code></li>
<li><code>getGenericCommand()</code>，在函数内调用<code>lookupKeyReadOrReply()</code>，并设置<code>null</code>为默认值。</li>
<li><code>lookupKeyReadOrReply()</code>在<code>client-&gt;db</code>中查找key，如果没有找到就返回默认值。</li>
</ol>
<h3 id="SET命令"><a href="#SET命令" class="headerlink" title="SET命令"></a><code>SET</code>命令</h3><p>将字符串值 <code>value</code> 关联到 <code>key</code> 。</p>
<p>如果 <code>key</code> 已经持有其他值， <code>SET</code> 就覆写旧值， 无视类型。</p>
<p>当 <code>SET</code> 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 <code>TTL</code> 将被清除。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-2"><a href="#命令形式-2" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>EX seconds</code> ： 将键的过期时间设置为 <code>seconds</code> 秒。 执行 <code>SET key value EX seconds</code> 的效果等同于执行 <code>SETEX key seconds value</code> 。</li>
<li><code>PX milliseconds</code> ： 将键的过期时间设置为 <code>milliseconds</code> 毫秒。 执行 <code>SET key value PX milliseconds</code> 的效果等同于执行 <code>PSETEX key milliseconds value</code> 。</li>
<li><code>NX</code> ： 只在键不存在时， 才对键进行设置操作。 执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code> 。</li>
<li><code>XX</code> ： 只在键已经存在时， 才对键进行设置操作。</li>
</ul>
<h4 id="内部实现函数-2"><a href="#内部实现函数-2" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="keyword">int</span> flags = OBJ_SET_NO_FLAGS;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 判断是否有 `EX` `PX` `NX` `XX`</span></span><br><span class="line">	 <span class="comment">// 并将其标志入flags中</span></span><br><span class="line">	 <span class="comment">// expire是保存过期时间</span></span><br><span class="line">	 <span class="comment">// unit 是保存过期时间的单位</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'n'</span> || a[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp;</span><br><span class="line">            (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; OBJ_SET_XX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_NX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'x'</span> || a[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_NX))</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_XX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'e'</span> || a[<span class="number">0</span>] == <span class="string">'E'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_PX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_EX;</span><br><span class="line">            unit = UNIT_SECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">'p'</span> || a[<span class="number">0</span>] == <span class="string">'P'</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">'x'</span> || a[<span class="number">1</span>] == <span class="string">'X'</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">'\0'</span> &amp;&amp;</span><br><span class="line">                   !(flags &amp; OBJ_SET_EX) &amp;&amp; next)</span><br><span class="line">        &#123;</span><br><span class="line">            flags |= OBJ_SET_PX;</span><br><span class="line">            unit = UNIT_MILLISECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 将 value 编码</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 判断是否需要设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">// 如果是需要设置过期时间，</span></span><br><span class="line">        <span class="comment">// 则从expire中获取，</span></span><br><span class="line">        <span class="comment">// 并将其转成 long long 类型保存入变量milliseconds中</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">"invalid expire time in %s"</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的单位是秒，则需要将变量milliseconds中的值转成毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 满足条件</span></span><br><span class="line">	 <span class="comment">// 1. 带NX参数，且DB中的key已经存在</span></span><br><span class="line">	 <span class="comment">// 或</span></span><br><span class="line">	 <span class="comment">// 2. 带XX参数，且DB中的key不存在</span></span><br><span class="line">	 <span class="comment">// 则返回空</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将键值对添加进c-&gt;db中</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 如果有过期时间，则会将过期时间和键值，保存到`c-&gt;db-&gt;expires`中</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds);</span><br><span class="line">    <span class="comment">// 触发键空间的事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"set"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">"expire"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SETNX命令"><a href="#SETNX命令" class="headerlink" title="SETNX命令"></a><code>SETNX</code>命令</h3><p>只在键 <code>key</code> 不存在的情况下， 将键 <code>key</code> 的值设置为 <code>value</code> 。</p>
<p>若键 <code>key</code> 已经存在， 则 <code>SETNX</code> 命令不做任何动作。</p>
<p><code>SETNX</code> 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<p>PS： 可以用来实现分布式锁。</p>
<h4 id="命令形式-3"><a href="#命令形式-3" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-3"><a href="#内部实现函数-3" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnxCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,OBJ_SET_NX,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">0</span>,shared.cone,shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用<code>setGenericCommand()</code>，详见<code>SET</code>的代码解析。</p>
<h3 id="SETEX命令"><a href="#SETEX命令" class="headerlink" title="SETEX命令"></a><code>SETEX</code>命令</h3><p>将键 <code>key</code> 的值设置为 <code>value</code> ， 并将键 <code>key</code> 的生存时间设置为 <code>seconds</code> 秒钟。</p>
<p>如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-4"><a href="#命令形式-4" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key value seconds</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-4"><a href="#内部实现函数-4" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setexCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,OBJ_SET_NO_FLAGS,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>],UNIT_SECONDS,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用<code>setGenericCommand()</code>，详见<code>SET</code>的代码解析。</p>
<h3 id="PSETEX命令"><a href="#PSETEX命令" class="headerlink" title="PSETEX命令"></a><code>PSETEX</code>命令</h3><p>与 <code>SETEX</code> 类似，差别在时间单位是毫秒。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-5"><a href="#命令形式-5" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key value milliseconds</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-5"><a href="#内部实现函数-5" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">psetexCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,OBJ_SET_NO_FLAGS,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>],UNIT_MILLISECONDS,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上是调用<code>setGenericCommand()</code>，详见<code>SET</code>的代码解析。</p>
<h3 id="APPEND命令"><a href="#APPEND命令" class="headerlink" title="APPEND命令"></a><code>APPEND</code>命令</h3><p>如果键 <code>key</code> 已经存在并且它的值是一个字符串， <code>APPEND</code> 命令将把 <code>value</code> 追加到键 <code>key</code> 现有值的末尾。</p>
<p>如果 <code>key</code> 不存在， <code>APPEND</code> 就简单地将键 <code>key</code> 的值设为 <code>value</code> ， 就像执行 <code>SET key value</code> 一样。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-6"><a href="#命令形式-6" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-6"><a href="#内部实现函数-6" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// totlen 是返回的新值的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 根据键获取值</span></span><br><span class="line">	 <span class="comment">// lookupKeyWrite() 会检查键是否已经过期</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有获取到对应键的值，则创建一个新键值对</span></span><br><span class="line">        <span class="comment">/* Create the key */</span></span><br><span class="line">        c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        totlen = stringObjectLen(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="comment">// 键存在，并检查值得类型</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,OBJ_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* "append" is an argument, so always an sds */</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 计算新字符串的长度值，并检查是否超过最大限制，默认为512MB</span></span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        <span class="comment">// 调用dbUnshareStringValue()</span></span><br><span class="line">        <span class="comment">// dbUnshareStringValue() 会检查字符串的引用，</span></span><br><span class="line">        <span class="comment">// 如果引用大于1，则函数会创建一个新的sds字符串返回,</span></span><br><span class="line">        <span class="comment">// 并将引用减1</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        <span class="comment">// 追加新值</span></span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"append"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReplyLongLong(c,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STRLEN命令"><a href="#STRLEN命令" class="headerlink" title="STRLEN命令"></a><code>STRLEN</code>命令</h3><p>返回键 <code>key</code> 储存的字符串值的长度。</p>
<p>当键 <code>key</code> 不存在时， 命令返回 <code>0</code> 。</p>
<p>当 <code>key</code> 储存的不是字符串值时， 返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>，只读，快速执行的命令，不应该被延迟。</li>
</ul>
<h4 id="命令形式-7"><a href="#命令形式-7" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-7"><a href="#内部实现函数-7" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strlenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 使用key（c-&gt;argv[1]）以只读模式获取值</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// stringObjectLen()是sds获取字符串长度的方法</span></span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DEL命令"><a href="#DEL命令" class="headerlink" title="DEL命令"></a><code>DEL</code>命令</h3><p>删除给定的一个或多个 <code>key</code> 。</p>
<ul>
<li><code>sflags</code>：<code>w</code>，写命令。</li>
</ul>
<h4 id="命令形式-8"><a href="#命令形式-8" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-8"><a href="#内部实现函数-8" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 0表示非延迟删除</span></span><br><span class="line">    delGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// DEL 命令可以接受多个key</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 检查键是否过期</span></span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="comment">// 通过lazy判断删除是否是延迟删除</span></span><br><span class="line">        <span class="comment">// 如果是延迟删除，则会调用异步删除</span></span><br><span class="line">        <span class="comment">// 如果不是，则会同步删除</span></span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><figure class="highlight plain"><figcaption><span>将删除操作，封装进一个BIO任务（多线程操作）中。在EventLoop的阻塞期间执行（可以参考[事件和事件循环](http://blog.mingforpc.me/2018/12/18/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/)）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* ```dbSyncDelete()```: 同步，直接`db`中删除键值对。</span><br><span class="line"></span><br><span class="line">### `UNLINK`命令</span><br><span class="line"></span><br><span class="line">延迟删除给定的一个或多个 `key` 。4.0 中加入，解决大KEY删除的问题。</span><br><span class="line"></span><br><span class="line">* `sflags`：`wF`，写命令，快速执行，不应该被延迟。</span><br><span class="line"></span><br><span class="line">#### 命令形式</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>DEL key [key …]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 内部实现函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">// db.c</span><br><span class="line">void unlinkCommand(client *c) &#123;</span><br><span class="line">    // 1 表示延迟删除</span><br><span class="line">    delGenericCommand(c,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>详见<code>DEL</code>中的详解。</p>
<h3 id="EXISTS命令"><a href="#EXISTS命令" class="headerlink" title="EXISTS命令"></a><code>EXISTS</code>命令</h3><p>检查给定 <code>key</code> 是否存在。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>，只读，快速执行命令，不应该被延迟。</li>
</ul>
<h4 id="命令形式-9"><a href="#命令形式-9" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key [key2... keyN]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-9"><a href="#内部实现函数-9" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* EXISTS key1 key2 ... key_N.</span></span><br><span class="line"><span class="comment"> * Return value is the number of keys existing. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">existsCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 在db（hash map）中检查key是否存在，</span></span><br><span class="line">        <span class="comment">// 并且会检查key是否过期的</span></span><br><span class="line">        <span class="keyword">if</span> (lookupKeyRead(c-&gt;db,c-&gt;argv[j])) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SETBIT命令"><a href="#SETBIT命令" class="headerlink" title="SETBIT命令"></a><code>SETBIT</code>命令</h3><p>对 <code>key</code> 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</p>
<p>位的设置或清除取决于 <code>value</code> 参数，可以是 <code>0</code> 也可以是 <code>1</code> 。</p>
<p>当 <code>key</code> 不存在时，自动生成一个新的字符串值。</p>
<p>字符串会进行伸展(grown)以确保它可以将 <code>value</code> 保存在指定的偏移量上。当字符串值进行伸展时，空白位置以 <code>0</code> 填充。</p>
<p><code>offset</code> 参数必须大于或等于 <code>0</code> ，小于 <code>2^32</code> (bit 映射被限制在 <code>512 MB</code> 之内)。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并且可能增加内存的使用。</li>
</ul>
<h4 id="命令形式-10"><a href="#命令形式-10" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset bitvalue</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-10"><a href="#内部实现函数-10" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitops.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SETBIT key offset bitvalue */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit is not an integer or out of range"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">ssize_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">int</span> byteval, bitval;</span><br><span class="line">    <span class="keyword">long</span> on;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 获取offset，并赋值到变量bitoffset中</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset,<span class="number">0</span>,<span class="number">0</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">// 获取bitvalue，并赋值到变量on中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;on,err) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">    <span class="comment">/* Bits can only be set or cleared... */</span></span><br><span class="line">    <span class="comment">// ~1 = 0xF...FFE</span></span><br><span class="line">    <span class="comment">// 所以, 如果 on &amp; ~1 &gt; 0</span></span><br><span class="line">    <span class="comment">// 表示 on 不等于（1或者0）</span></span><br><span class="line">    <span class="keyword">if</span> (on &amp; ~<span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">// 专门给位运算实现的函数</span></span><br><span class="line">	 <span class="comment">// 当 key 保存的值 不是 字符串类型，则会返回NULL</span></span><br><span class="line">	 <span class="comment">// 如果 key 不存在，则会生产指定长度butoffset的的字符串</span></span><br><span class="line">	 <span class="comment">// 如果 key 已经存在，且字符串长度不够，则会扩展至指定长度butoffset</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupStringForBitCommand(c,bitoffset)) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get current values */</span></span><br><span class="line">    <span class="comment">// bitoffset &gt;&gt; 3 表示左移3位，既整除8，按照byte大小运算</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    byteval = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte];</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    <span class="comment">// bitval 是原本的值</span></span><br><span class="line">    bitval = byteval &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update byte with new bit value and return original value */</span></span><br><span class="line">    byteval &amp;= ~(<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    byteval |= ((on &amp; <span class="number">0x1</span>) &lt;&lt; bit);</span><br><span class="line">    <span class="comment">// 赋新值</span></span><br><span class="line">    ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte] = byteval;</span><br><span class="line">    <span class="comment">// 消息通知</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"setbit"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GETBIT命令"><a href="#GETBIT命令" class="headerlink" title="GETBIT命令"></a><code>GETBIT</code>命令</h3><p>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</p>
<p>当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 0 。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>，只读，快速执行命令，不应该被延迟。</li>
</ul>
<h4 id="命令形式-11"><a href="#命令形式-11" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-11"><a href="#内部实现函数-11" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitops.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GETBIT key offset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getbitCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">size_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">size_t</span> bitval = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 获取offset，并赋值到变量bitoffset中</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset,<span class="number">0</span>,<span class="number">0</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取值并检查是否是sds字符串格式</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">// 按byte计算偏移量</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    <span class="comment">// 判断值o的sds保存格式，因为sds会有字符串格式和整数格式</span></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">    <span class="comment">// 字符串格式</span></span><br><span class="line">        <span class="keyword">if</span> (byte &lt; sdslen(o-&gt;ptr))</span><br><span class="line">            </span><br><span class="line">            bitval = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 整数格式</span></span><br><span class="line">        <span class="comment">// 通过ll2string()将long long格式转为字节大小的数值表示</span></span><br><span class="line">        <span class="keyword">if</span> (byte &lt; (<span class="keyword">size_t</span>)ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr))</span><br><span class="line">            bitval = llbuf[byte] &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于Redis中字符串的数据结构和编码可以看<a href="http://blog.mingforpc.me/2018/09/22/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%BC%96%E7%A0%81/" target="_blank" rel="noopener">对象及其类型和编码</a>。</p>
<h3 id="BITFIELD命令"><a href="#BITFIELD命令" class="headerlink" title="BITFIELD命令"></a><code>BITFIELD</code>命令</h3><p><code>BITFIELD</code> 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组， 并对这个数组中储存的长度不同的整数进行访问 （被储存的整数无需进行对齐）。 换句话说， 通过这个命令， 用户可以执行诸如 “对偏移量 1234 上的 5 位长有符号整数进行设置”、 “获取偏移量 4567 上的 31 位长无符号整数”等操作。 此外， <code>BITFIELD</code> 命令还可以对指定的整数执行加法操作和减法操作， 并且这些操作可以通过设置妥善地处理计算时出现的溢出情况。</p>
<p><code>BITFIELD</code> 命令可以在一次调用中同时对多个位范围进行操作： 它接受一系列待执行的操作作为参数， 并返回一个数组作为回复， 数组中的每个元素就是对应操作的执行结果。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并且可能增加内存的使用。</li>
</ul>
<h4 id="命令形式-12"><a href="#命令形式-12" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BITFIELD key subcommmand-1 arg ... subcommand-2 arg ... subcommand-N ...</span><br></pre></td></tr></table></figure>
<p>子命令支持:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &lt;type&gt; &lt;offset&gt;</span><br><span class="line">SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</span><br><span class="line">INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</span><br><span class="line">OVERFLOW [WRAP|SAT|FAIL]</span><br></pre></td></tr></table></figure>
<p><code>type</code>为指定的二进制范围，<code>i</code>表示有符号整数，<code>u</code>表示无符号整数。例如<code>u8</code>表示8位长的无符号整数，<code>i16</code>表示16位长的有符号整数。</p>
<ul>
<li><code>GET &lt;type&gt; &lt;offset&gt;</code>: 返回指定的二进制位范围。</li>
<li><code>SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</code>: 对指定的二进制位范围进行设置，并返回旧值。</li>
<li><code>INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</code>: 对指定的二进制位范围进行加法操作，并返回旧值。</li>
<li><code>OVERFLOW [WRAP|SAT|FAIL]</code>: 溢出控制:<ul>
<li><code>WRAP</code>: 使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。 对于无符号整数来说， 回绕就像使用数值本身与能够被储存的最大无符号整数执行取模计算， 这也是 C 语言的标准行为。 对于有符号整数来说， 上溢将导致数字重新从最小的负数开始计算， 而下溢将导致数字重新从最大的正数开始计算。 比如说， 如果我们对一个值为 <code>127</code> 的 <code>i8</code> 整数执行加<code>1</code>操作， 那么将得到结果 <code>-128</code> 。</li>
<li><code>SAT</code>: 使用饱和计算（saturation arithmetic）方法处理溢出， 也即是说， 下溢计算的结果为最小的整数值， 而上溢计算的结果为最大的整数值。 举个例子， 如果我们对一个值为 <code>120</code> 的 <code>i8</code> 整数执行加 <code>10</code> 计算， 那么命令的结果将为 <code>i8</code> 类型所能储存的最大整数值 <code>127</code> 。 与此相反， 如果一个针对 <code>i8</code> 值的计算造成了下溢， 那么这个 <code>i8</code> 值将被设置为 <code>-127</code> 。</li>
<li><code>FAIL</code> ： 在这一模式下， 命令将拒绝执行那些会导致上溢或者下溢情况出现的计算， 并向用户返回空值表示计算未被执行。</li>
</ul>
</li>
</ul>
<h4 id="内部实现函数-12"><a href="#内部实现函数-12" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bittops.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* BITFIELD key subcommmand-1 arg ... subcommand-2 arg ... subcommand-N ...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Supported subcommands:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * GET &lt;type&gt; &lt;offset&gt;</span></span><br><span class="line"><span class="comment"> * SET &lt;type&gt; &lt;offset&gt; &lt;value&gt;</span></span><br><span class="line"><span class="comment"> * INCRBY &lt;type&gt; &lt;offset&gt; &lt;increment&gt;</span></span><br><span class="line"><span class="comment"> * OVERFLOW [WRAP|SAT|FAIL]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子命令的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitfieldOp</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> offset;    <span class="comment">/* Bitfield offset. */</span></span><br><span class="line">    <span class="keyword">int64_t</span> i64;        <span class="comment">/* Increment amount (INCRBY) or SET value */</span></span><br><span class="line">    <span class="keyword">int</span> opcode;         <span class="comment">/* Operation id. */</span></span><br><span class="line">    <span class="keyword">int</span> owtype;         <span class="comment">/* Overflow type to use. */</span></span><br><span class="line">    <span class="keyword">int</span> bits;           <span class="comment">/* Integer bitfield bits width. */</span></span><br><span class="line">    <span class="keyword">int</span> sign;           <span class="comment">/* True if signed, otherwise unsigned op. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitfieldCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">int</span> j, numops = <span class="number">0</span>, changes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 保存操作的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitfieldOp</span> *<span class="title">ops</span> = <span class="title">NULL</span>;</span> <span class="comment">/* Array of ops to execute at end. */</span></span><br><span class="line">    <span class="keyword">int</span> owtype = BFOVERFLOW_WRAP; <span class="comment">/* Overflow type. */</span></span><br><span class="line">    <span class="keyword">int</span> readonly = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> higest_write_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中解析操作，保存到`ops`中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// `remargs` 是用来判断参数是否足够的</span></span><br><span class="line">        <span class="keyword">int</span> remargs = c-&gt;argc-j<span class="number">-1</span>; <span class="comment">/* Remaining args other than current. */</span></span><br><span class="line">        <span class="keyword">char</span> *subcmd = c-&gt;argv[j]-&gt;ptr; <span class="comment">/* Current command name. */</span></span><br><span class="line">        <span class="keyword">int</span> opcode; <span class="comment">/* Current operation code. */</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i64 = <span class="number">0</span>;  <span class="comment">/* Signed SET value. */</span></span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">0</span>; <span class="comment">/* Signed or unsigned type? */</span></span><br><span class="line">        <span class="keyword">int</span> bits = <span class="number">0</span>; <span class="comment">/* Bitfield width in bits. */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"get"</span>) &amp;&amp; remargs &gt;= <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// GET的子命令</span></span><br><span class="line">            opcode = BITFIELDOP_GET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"set"</span>) &amp;&amp; remargs &gt;= <span class="number">3</span>)</span><br><span class="line">            <span class="comment">// SET的子命令</span></span><br><span class="line">            opcode = BITFIELDOP_SET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"incrby"</span>) &amp;&amp; remargs &gt;= <span class="number">3</span>)</span><br><span class="line">            <span class="comment">// INCRBY的子命令</span></span><br><span class="line">            opcode = BITFIELDOP_INCRBY;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(subcmd,<span class="string">"overflow"</span>) &amp;&amp; remargs &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置溢出处理</span></span><br><span class="line">            <span class="keyword">char</span> *owtypename = c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(owtypename,<span class="string">"wrap"</span>))</span><br><span class="line">                owtype = BFOVERFLOW_WRAP;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(owtypename,<span class="string">"sat"</span>))</span><br><span class="line">                owtype = BFOVERFLOW_SAT;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(owtypename,<span class="string">"fail"</span>))</span><br><span class="line">                owtype = BFOVERFLOW_FAIL;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyError(c,<span class="string">"Invalid OVERFLOW type specified"</span>);</span><br><span class="line">                zfree(ops);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            zfree(ops);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get the type and offset arguments, common to all the ops. */</span></span><br><span class="line">        <span class="comment">// getBitfieldTypeFromArgument() 获取命令行中的, `type`</span></span><br><span class="line">        <span class="comment">// type 是有取值范围的</span></span><br><span class="line">        <span class="comment">// 当是有符号整数时，支持 i1 &lt; x &lt; i64</span></span><br><span class="line">        <span class="comment">// 当是无符号整数时，支持 u1 &lt; x &lt; u63</span></span><br><span class="line">        <span class="keyword">if</span> (getBitfieldTypeFromArgument(c,c-&gt;argv[j+<span class="number">1</span>],&amp;sign,&amp;bits) != C_OK) &#123;</span><br><span class="line">            zfree(ops);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getBitOffsetFromArgument() 获取命令行中的, `offset`</span></span><br><span class="line">        <span class="comment">// offset 存在大小限制，必须是  -1 &lt; offset </span></span><br><span class="line">        <span class="comment">// 而且，offset通过bit转换后，大小是要先知道 512*1024*1024 bytes(512MB)以内</span></span><br><span class="line">        <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[j+<span class="number">2</span>],&amp;bitoffset,<span class="number">1</span>,bits) != C_OK)&#123;</span><br><span class="line">            zfree(ops);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除了 Get以外, SET 和 INCRBY 都有第3个参数</span></span><br><span class="line">        <span class="keyword">if</span> (opcode != BITFIELDOP_GET) &#123;</span><br><span class="line">            readonly = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (higest_write_offset &lt; bitoffset + bits - <span class="number">1</span>)</span><br><span class="line">                higest_write_offset = bitoffset + bits - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/* INCRBY and SET require another argument. */</span></span><br><span class="line">            <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[j+<span class="number">3</span>],&amp;i64,<span class="literal">NULL</span>) != C_OK)&#123;</span><br><span class="line">                zfree(ops);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate the array of operations we'll process. */</span></span><br><span class="line">        <span class="comment">// 构成bitfieldOp结构体，保存入ops中</span></span><br><span class="line">        ops = zrealloc(ops,<span class="keyword">sizeof</span>(*ops)*(numops+<span class="number">1</span>));</span><br><span class="line">        ops[numops].offset = bitoffset;</span><br><span class="line">        ops[numops].i64 = i64;</span><br><span class="line">        ops[numops].opcode = opcode;</span><br><span class="line">        ops[numops].owtype = owtype;</span><br><span class="line">        ops[numops].bits = bits;</span><br><span class="line">        ops[numops].sign = sign;</span><br><span class="line">        numops++;</span><br><span class="line"></span><br><span class="line">        j += <span class="number">3</span> - (opcode == BITFIELDOP_GET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// readonly 标记为记录子命令中是否存在写的命令</span></span><br><span class="line">    <span class="keyword">if</span> (readonly) &#123;</span><br><span class="line">        <span class="comment">/* Lookup for read is ok if key doesn't exit, but errors</span></span><br><span class="line"><span class="comment">         * if it's not a string. */</span></span><br><span class="line">        o = lookupKeyRead(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Lookup by making room up to the farest bit reached by</span></span><br><span class="line"><span class="comment">         * this operation. */</span></span><br><span class="line">        <span class="keyword">if</span> ((o = lookupStringForBitCommand(c,</span><br><span class="line">            higest_write_offset)) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyMultiBulkLen(c,numops);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Actually process the operations. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numops; j++) &#123;</span><br><span class="line">        <span class="comment">// 执行各个命令 </span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">bitfieldOp</span> *<span class="title">thisop</span> = <span class="title">ops</span>+<span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Execute the operation. */</span></span><br><span class="line">        <span class="keyword">if</span> (thisop-&gt;opcode == BITFIELDOP_SET ||</span><br><span class="line">            thisop-&gt;opcode == BITFIELDOP_INCRBY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* SET and INCRBY: We handle both with the same code path</span></span><br><span class="line"><span class="comment">             * for simplicity. SET return value is the previous value so</span></span><br><span class="line"><span class="comment">             * we need fetch &amp; store as well. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We need two different but very similar code paths for signed</span></span><br><span class="line"><span class="comment">             * and unsigned operations, since the set of functions to get/set</span></span><br><span class="line"><span class="comment">             * the integers and the used variables types are different. */</span></span><br><span class="line">            <span class="keyword">if</span> (thisop-&gt;sign) &#123;</span><br><span class="line">                <span class="comment">// 有符号整数</span></span><br><span class="line">                <span class="keyword">int64_t</span> oldval, newval, wrapped, retval;</span><br><span class="line">                <span class="keyword">int</span> overflow;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取旧值</span></span><br><span class="line">                oldval = getSignedBitfield(o-&gt;ptr,thisop-&gt;offset,</span><br><span class="line">                        thisop-&gt;bits);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (thisop-&gt;opcode == BITFIELDOP_INCRBY) &#123;</span><br><span class="line">                    <span class="comment">// INCRBY</span></span><br><span class="line">                    newval = oldval + thisop-&gt;i64;</span><br><span class="line">                    <span class="comment">// 检查Overflow</span></span><br><span class="line">                    overflow = checkSignedBitfieldOverflow(oldval,</span><br><span class="line">                            thisop-&gt;i64,thisop-&gt;bits,thisop-&gt;owtype,&amp;wrapped);</span><br><span class="line">                    <span class="keyword">if</span> (overflow) newval = wrapped;</span><br><span class="line">                    retval = newval;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// SET</span></span><br><span class="line">                    newval = thisop-&gt;i64;</span><br><span class="line">                    <span class="comment">// 检查Overflow</span></span><br><span class="line">                    overflow = checkSignedBitfieldOverflow(newval,</span><br><span class="line">                            <span class="number">0</span>,thisop-&gt;bits,thisop-&gt;owtype,&amp;wrapped);</span><br><span class="line">                    <span class="keyword">if</span> (overflow) newval = wrapped;</span><br><span class="line">                    retval = oldval;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* On overflow of type is "FAIL", don't write and return</span></span><br><span class="line"><span class="comment">                 * NULL to signal the condition. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(overflow &amp;&amp; thisop-&gt;owtype == BFOVERFLOW_FAIL)) &#123;</span><br><span class="line">                    addReplyLongLong(c,retval);</span><br><span class="line">                    setSignedBitfield(o-&gt;ptr,thisop-&gt;offset,</span><br><span class="line">                                      thisop-&gt;bits,newval);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    addReply(c,shared.nullbulk);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无符号整数</span></span><br><span class="line">                <span class="keyword">uint64_t</span> oldval, newval, wrapped, retval;</span><br><span class="line">                <span class="keyword">int</span> overflow;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取旧值</span></span><br><span class="line">                oldval = getUnsignedBitfield(o-&gt;ptr,thisop-&gt;offset,</span><br><span class="line">                        thisop-&gt;bits);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (thisop-&gt;opcode == BITFIELDOP_INCRBY) &#123;</span><br><span class="line">                    <span class="comment">// INCRBY</span></span><br><span class="line">                    newval = oldval + thisop-&gt;i64;</span><br><span class="line">                    overflow = checkUnsignedBitfieldOverflow(oldval,</span><br><span class="line">                            thisop-&gt;i64,thisop-&gt;bits,thisop-&gt;owtype,&amp;wrapped);</span><br><span class="line">                    <span class="keyword">if</span> (overflow) newval = wrapped;</span><br><span class="line">                    retval = newval;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">// SET</span></span><br><span class="line">                    newval = thisop-&gt;i64;</span><br><span class="line">                    overflow = checkUnsignedBitfieldOverflow(newval,</span><br><span class="line">                            <span class="number">0</span>,thisop-&gt;bits,thisop-&gt;owtype,&amp;wrapped);</span><br><span class="line">                    <span class="keyword">if</span> (overflow) newval = wrapped;</span><br><span class="line">                    retval = oldval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* On overflow of type is "FAIL", don't write and return</span></span><br><span class="line"><span class="comment">                 * NULL to signal the condition. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(overflow &amp;&amp; thisop-&gt;owtype == BFOVERFLOW_FAIL)) &#123;</span><br><span class="line">                    addReplyLongLong(c,retval);</span><br><span class="line">                    setUnsignedBitfield(o-&gt;ptr,thisop-&gt;offset,</span><br><span class="line">                                        thisop-&gt;bits,newval);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    addReply(c,shared.nullbulk);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            changes++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* GET */</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="built_in">strlen</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">char</span> llbuf[LONG_STR_SIZE];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (o != <span class="literal">NULL</span>)</span><br><span class="line">                src = getObjectReadOnlyString(o,&amp;<span class="built_in">strlen</span>,llbuf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* For GET we use a trick: before executing the operation</span></span><br><span class="line"><span class="comment">             * copy up to 9 bytes to a local buffer, so that we can easily</span></span><br><span class="line"><span class="comment">             * execute up to 64 bit operations that are at actual string</span></span><br><span class="line"><span class="comment">             * object boundaries. */</span></span><br><span class="line">            <span class="comment">// 因为之前看，取值范围是有限制的，所以使用最多9个字节处理</span></span><br><span class="line">            <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">size_t</span> byte = thisop-&gt;offset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (src == <span class="literal">NULL</span> || i+byte &gt;= (<span class="keyword">size_t</span>)<span class="built_in">strlen</span>) <span class="keyword">break</span>;</span><br><span class="line">                buf[i] = src[i+byte];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Now operate on the copied buffer which is guaranteed</span></span><br><span class="line"><span class="comment">             * to be zero-padded. */</span></span><br><span class="line">            <span class="keyword">if</span> (thisop-&gt;sign) &#123;</span><br><span class="line">                <span class="comment">// 有符号整数</span></span><br><span class="line">                <span class="keyword">int64_t</span> val = getSignedBitfield(buf,thisop-&gt;offset-(byte*<span class="number">8</span>),</span><br><span class="line">                                            thisop-&gt;bits);</span><br><span class="line">                addReplyLongLong(c,val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 无符号整数</span></span><br><span class="line">                <span class="keyword">uint64_t</span> val = getUnsignedBitfield(buf,thisop-&gt;offset-(byte*<span class="number">8</span>),</span><br><span class="line">                                            thisop-&gt;bits);</span><br><span class="line">                addReplyLongLong(c,val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changes) &#123;</span><br><span class="line">        <span class="comment">// 如果值改变了，则发送消息</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"setbit"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty += changes;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SETRANGE命令"><a href="#SETRANGE命令" class="headerlink" title="SETRANGE命令"></a><code>SETRANGE</code>命令</h3><p>从偏移量 <code>offset</code> 开始， 用 <code>value</code> 参数覆写(overwrite)键 <code>key</code> 储存的字符串值。</p>
<p>不存在的键 <code>key</code> 当作空白字符串处理。</p>
<p><code>SETRANGE</code> 命令会确保字符串足够长以便将 <code>value</code> 设置到指定的偏移量上， 如果键 <code>key</code> 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 <code>offset</code> 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, <code>&quot;\x00&quot;</code> )进行填充。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并且可能增加内存的使用。</li>
</ul>
<h4 id="命令形式-13"><a href="#命令形式-13" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETRANGE key offset value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-13"><a href="#内部实现函数-13" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setrangeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    sds value = c-&gt;argv[<span class="number">3</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取offset</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;offset,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset必须大于等于0</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"offset is out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在db中根据键寻找值</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Return 0 when setting nothing on a non-existing string */</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当键的值不存在，且value为空，则直接返回0</span></span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">// 判断设置偏移后，总长度是否大于512MB（由于这个键不存在，所以这里的其实检查了offset的大小）</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接创建一个sds字符串，并加入db</span></span><br><span class="line">        o = createObject(OBJ_STRING,sdsnewlen(<span class="literal">NULL</span>, offset+sdslen(value)));</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> olen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查值得蕾西，需要时string</span></span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,OBJ_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return existing string length when setting nothing */</span></span><br><span class="line">        olen = stringObjectLen(o);</span><br><span class="line">        <span class="keyword">if</span> (sdslen(value) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// value为空，表示不设置值，直接返回</span></span><br><span class="line">            addReplyLongLong(c,olen);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Return when the resulting string exceeds allowed size */</span></span><br><span class="line">        <span class="comment">// 判断设置偏移后，总长度是否大于512MB</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,offset+sdslen(value)) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a copy when the object is shared or encoded. */</span></span><br><span class="line">        <span class="comment">// 保存值，dbUnshareStringValue()会处理redisObject的引用问题</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(value) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 发小键值变化的消息</span></span><br><span class="line">        o-&gt;ptr = sdsgrowzero(o-&gt;ptr,offset+sdslen(value));</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">char</span>*)o-&gt;ptr+offset,value,sdslen(value));</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,</span><br><span class="line">            <span class="string">"setrange"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,sdslen(o-&gt;ptr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="GETRANGE命令"><a href="#GETRANGE命令" class="headerlink" title="GETRANGE命令"></a><code>GETRANGE</code>命令</h3><p>返回键 <code>key</code> 储存的字符串值的指定部分， 字符串的截取范围由 <code>start</code> 和 <code>end</code> 两个偏移量决定 (包括 <code>start</code> 和 <code>end</code> 在内)。</p>
<p>负数偏移量表示从字符串的末尾开始计数， <code>-1</code> 表示最后一个字符， <code>-2</code> 表示倒数第二个字符， 以此类推。</p>
<p><code>GETRANGE</code> 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</p>
<ul>
<li><code>sflags</code>：<code>r</code>，只读命令。</li>
</ul>
<h4 id="命令形式-14"><a href="#命令形式-14" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE key start end</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-14"><a href="#内部实现函数-14" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrangeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start, end;</span><br><span class="line">    <span class="keyword">char</span> *str, llbuf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">strlen</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从参数中获取 start</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;start,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从参数中获取 end</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;end,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据 key 获取其值 o, 并检查数据类型是否为redis字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptybulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果字符串中保存的是整型，则转成字符串形式</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        str = llbuf;</span><br><span class="line">        <span class="built_in">strlen</span> = ll2string(llbuf,<span class="keyword">sizeof</span>(llbuf),(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = o-&gt;ptr;</span><br><span class="line">        <span class="built_in">strlen</span> = sdslen(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对不正确的start，end进行处理</span></span><br><span class="line">    <span class="comment">/* Convert negative indexes */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; end &lt; <span class="number">0</span> &amp;&amp; start &gt; end) &#123;</span><br><span class="line">        addReply(c,shared.emptybulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对负数的（start, end）和越界的end进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="built_in">strlen</span>+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="built_in">strlen</span>+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)end &gt;= <span class="built_in">strlen</span>) end = <span class="built_in">strlen</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Precondition: end &gt;= 0 &amp;&amp; end &lt; strlen, so the only condition where</span></span><br><span class="line"><span class="comment">     * nothing can be returned is: start &gt; end. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || <span class="built_in">strlen</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// start &gt; end 的错误情况</span></span><br><span class="line">        <span class="comment">// strlen == 0 的情况（PS：为什么这里不提前判断？提前判断了就不用做start和end的运算了。不过可能考虑的是代码的可读性，毕竟start和end的运行应该也花不了多少时间）</span></span><br><span class="line">        addReply(c,shared.emptybulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulkCBuffer(c,(<span class="keyword">char</span>*)str+start,end-start+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SUBSTR命令"><a href="#SUBSTR命令" class="headerlink" title="SUBSTR命令"></a><code>SUBSTR</code>命令</h3><p>在Redis 2.0 之前，<code>SUBSTR</code>其实是<code>GETRANGE</code>。现在的实现也是一样的，所以参照<code>GETRANGE</code></p>
<ul>
<li><code>sflags</code>：<code>r</code>，只读命令。</li>
</ul>
<h3 id="INCR命令"><a href="#INCR命令" class="headerlink" title="INCR命令"></a><code>INCR</code>命令</h3><p>为键 <code>key</code> 储存的数字值加上<code>1</code>。</p>
<p>如果键 <code>key</code> 不存在， 那么它的值会先被初始化为 <code>0</code> ， 然后再执行 <code>INCR</code> 命令。</p>
<p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 <code>INCR</code> 命令将返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-15"><a href="#命令形式-15" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-15"><a href="#内部实现函数-15" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其实`INCR`,`INCRBY`,`DECR`,`DECRBY`都是调用的incrDecrCommand()函数</span></span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询键对应的值o</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查值o的类型</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从o中获取整数值value（可能是sds的）</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断相加后，是否会造成越界，不能超过LLONG_MIN，也不能小于LLONG_MAX</span></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"increment or decrement would overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value += incr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; o-&gt;refcount == <span class="number">1</span> &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">        (value &lt; <span class="number">0</span> || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</span><br><span class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这是判断 值 o 是存在的，而且不在 OBJ_SHARED_INTEGERS （Redis初始化的共享整数）范围内</span></span><br><span class="line">        <span class="comment">// 而且没有其他键引用到o（o-&gt;refcount == 1）</span></span><br><span class="line">        <span class="comment">// 所以可以直接修改o中的值</span></span><br><span class="line">        <span class="keyword">new</span> = o;</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// createStringObjectFromLongLong() 会判断值value是否在 OBJ_SHARED_INTEGERS 的范围内</span></span><br><span class="line">        <span class="comment">// 如果在范围内，则直接引用共享的整数对象</span></span><br><span class="line">        <span class="comment">// 如果不是，则创建新的对象</span></span><br><span class="line">        <span class="keyword">new</span> = createStringObjectFromLongLong(value);</span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            <span class="comment">// 原本键值对已经存在，则覆盖</span></span><br><span class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 原本键值不存在，则添加</span></span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"incrby"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,<span class="keyword">new</span>);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DECR命令"><a href="#DECR命令" class="headerlink" title="DECR命令"></a><code>DECR</code>命令</h3><p>为键 <code>key</code> 储存的数字值减去<code>1</code>。</p>
<p>如果键 <code>key</code> 不存在， 那么键 <code>key</code> 的值会先被初始化为 <code>0</code> ， 然后再执行 <code>DECR</code> 操作。</p>
<p>如果键 <code>key</code> 储存的值不能被解释为数字， 那么 <code>DECR</code> 命令将返回一个错误。</p>
<p>本操作的值限制在 64 位(bit)有符号数字表示之内。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-16"><a href="#命令形式-16" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-16"><a href="#内部实现函数-16" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>incrDecrCommand()</code>的解析参照<code>INCR</code>。</p>
<h3 id="MGET命令"><a href="#MGET命令" class="headerlink" title="MGET命令"></a><code>MGET</code>命令</h3><p>返回所有(一个或多个)给定 <code>key</code> 的值。</p>
<p>如果给定的 <code>key</code> 里面，有某个 <code>key</code> 不存在，那么这个 <code>key</code> 返回特殊值 <code>nil</code>。因此，该命令永不失败。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>，只读操作。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-17"><a href="#命令形式-17" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-17"><a href="#内部实现函数-17" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_string.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mgetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 返回客户端要执行的命令数量</span></span><br><span class="line">    addReplyMultiBulkLen(c,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 在DB中查找对应的值,并返回</span></span><br><span class="line">        robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">                <span class="comment">// 只返回字符串类型</span></span><br><span class="line">                addReply(c,shared.nullbulk);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulk(c,o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPUSH命令"><a href="#RPUSH命令" class="headerlink" title="RPUSH命令"></a><code>RPUSH</code>命令</h3><p>将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表尾(最右边)。 。</p>
<p>如果 <code>key</code> 不存在，一个空列表会被创建并执行 <code>RPUSH</code> 操作。</p>
<p>当 <code>key</code> 存在但不是列表类型时，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-18"><a href="#命令形式-18" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-18"><a href="#内部实现函数-18" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// RPUSH 和 LPUSH公用的函数</span></span><br><span class="line">    pushxGenericCommand(c,LIST_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RPUSH</code>和<code>LPUSH</code>只是插入位置不同，功能相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, pushed = <span class="number">0</span>;</span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断键的类型</span></span><br><span class="line">    <span class="keyword">if</span> (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">            <span class="comment">// 如果本来是空键,则新建 quick list, 并添加到db中</span></span><br><span class="line">            lobj = createQuicklistObject();</span><br><span class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                                server.list_compress_depth);</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">        &#125;</span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回列表的长度</span></span><br><span class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="comment">// 如果有成功插入的,触发对应事件</span></span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpush"</span> : <span class="string">"rpush"</span>;</span><br><span class="line"></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * List API</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The function pushes an element to the specified list object 'subject',</span></span><br><span class="line"><span class="comment"> * at head or tail position as specified by 'where'.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is no need for the caller to increment the refcount of 'value' as</span></span><br><span class="line"><span class="comment"> * the function takes care of it if needed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 新版本的Redis,已经将所有的列表实现换成 quick list</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line">        <span class="comment">// 对val进行decode, 因为value有可能是字符串或者整型</span></span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="keyword">size_t</span> len = sdslen(value-&gt;ptr);</span><br><span class="line">        <span class="comment">// quick list的插入方法</span></span><br><span class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LPUSH命令"><a href="#LPUSH命令" class="headerlink" title="LPUSH命令"></a><code>LPUSH</code>命令</h3><p>将一个或多个值 <code>value</code> 插入到列表 <code>key</code> 的表头(最左边)。 。</p>
<p>如果 <code>key</code> 不存在，一个空列表会被创建并执行 <code>LPUSH</code> 操作。</p>
<p>当 <code>key</code> 存在但不是列表类型时，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-19"><a href="#命令形式-19" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-19"><a href="#内部实现函数-19" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpushxCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    pushxGenericCommand(c,LIST_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他具体看<code>RPUSH</code>。</p>
<h3 id="RPUSHX命令"><a href="#RPUSHX命令" class="headerlink" title="RPUSHX命令"></a><code>RPUSHX</code>命令</h3><p>将值 <code>value</code> 插入到列表 <code>key</code> 的表尾，<strong>当且仅当</strong> <code>key</code> 存在并且是一个列表。</p>
<p>和 <code>RPUSH</code> 命令相反，当 <code>key</code> 不存在时， <code>RPUSHX</code> 命令什么也不做。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-20"><a href="#命令形式-20" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSHX key value [value ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-20"><a href="#内部实现函数-20" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpushxCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// RPUSHX 和 LPUSHX 公用的函数</span></span><br><span class="line">    pushxGenericCommand(c,LIST_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RPUSHX</code> 和 <code>LPUSHX</code>只是插入位置不同，功能相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushxGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, pushed = <span class="number">0</span>;</span><br><span class="line">    robj *subject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从db中获取指定的列表键的值，并判断是否为列表</span></span><br><span class="line">    <span class="keyword">if</span> ((subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,subject,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// Push的方法</span></span><br><span class="line">        listTypePush(subject,c-&gt;argv[j],where);</span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回列表的长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(subject));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="comment">// 如果有成功插入的,触发对应事件</span></span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpush"</span> : <span class="string">"rpush"</span>;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### `LPUSHX`命令</span><br><span class="line"></span><br><span class="line">将值 `value` 插入到列表 `key` 的表头，**当且仅当** `key` 存在并且是一个列表。</span><br><span class="line"></span><br><span class="line">和 `LPUSH` 命令相反，当 `key` 不存在时， `LPUSHX` 命令什么也不做。</span><br><span class="line"></span><br><span class="line">* `sflags`：`wmF`，写命令，并可能导致增加内存的使用。快速执行，不应该被延迟。</span><br><span class="line"></span><br><span class="line">#### 命令形式</span><br></pre></td></tr></table></figure>
<p>LPUSHX key value [value …]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 内部实现函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">// t_list.c</span><br><span class="line">void lpushxCommand(client *c) &#123;</span><br><span class="line">    pushxGenericCommand(c,LIST_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体参照<code>RPUSHX</code>。</p>
<h3 id="LINSERT命令"><a href="#LINSERT命令" class="headerlink" title="LINSERT命令"></a><code>LINSERT</code>命令</h3><p>将值 <code>value</code> 插入到列表 <code>key</code> 当中，位于值 <code>pivot</code> 之前或之后。</p>
<p>当 <code>pivot</code> 不存在于列表 <code>key</code> 时，不执行任何操作。</p>
<p>当 <code>key</code> 不存在时， <code>key</code> 被视为空列表，不执行任何操作。</p>
<p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-21"><a href="#命令形式-21" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-21"><a href="#内部实现函数-21" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linsertCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> where;</span><br><span class="line">    robj *subject;</span><br><span class="line">    listTypeIterator *iter;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">int</span> inserted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是在指定位置前插入还是指定位置后插入</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"after"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        where = LIST_TAIL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">"before"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        where = LIST_HEAD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从db中取出对应的key,并判断数据类型是否为list</span></span><br><span class="line">    <span class="keyword">if</span> ((subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,subject,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Seek pivot from head to tail */</span></span><br><span class="line">    <span class="comment">// 获取list的迭代器(封装了quick list的迭代)</span></span><br><span class="line">    iter = listTypeInitIterator(subject,<span class="number">0</span>,LIST_TAIL);</span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(iter,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,c-&gt;argv[<span class="number">3</span>])) &#123;</span><br><span class="line">            <span class="comment">// 查找位置,并插入</span></span><br><span class="line">            listTypeInsert(&amp;entry,c-&gt;argv[<span class="number">4</span>],where);</span><br><span class="line">            inserted = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listTypeReleaseIterator(iter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">        <span class="comment">// 如果有插入触发事件</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">"linsert"</span>,</span><br><span class="line">                            c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Notify client of a failed insert */</span></span><br><span class="line">        addReply(c,shared.cnegone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回列表长度</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(subject));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPOP命令"><a href="#RPOP命令" class="headerlink" title="RPOP命令"></a><code>RPOP</code>命令</h3><p>移除并返回列表 <code>key</code> 的尾(最右)元素。</p>
<ul>
<li><code>sflags</code>：<code>wF</code>，写命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-22"><a href="#命令形式-22" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-22"><a href="#内部实现函数-22" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RPOP</code> 和 <code>LPOP</code>只是位置不同，功能相同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找对应的键, 并判断类型</span></span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从尾取出值</span></span><br><span class="line">    robj *value = listTypePop(o,where);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有值取出(长度为0，一般不会出现)</span></span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpop"</span> : <span class="string">"rpop"</span>;</span><br><span class="line">        <span class="comment">// 返回取出的值</span></span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        <span class="comment">// 引用次数减1</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        <span class="comment">// 触发对应事件</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果取出值后,列表长度为0,则直接删除列表</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function">robj *<span class="title">listTypePop</span><span class="params">(robj *subject, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line">    <span class="comment">//判断类型, 现在列表的实现只剩下quick list</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// quick list 的取出操作</span></span><br><span class="line">        <span class="keyword">if</span> (quicklistPopCustom(subject-&gt;ptr, ql_where, (<span class="keyword">unsigned</span> <span class="keyword">char</span> **)&amp;value,</span><br><span class="line">                               <span class="literal">NULL</span>, &amp;vlong, listPopSaver)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!value)</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LPOP命令"><a href="#LPOP命令" class="headerlink" title="LPOP命令"></a><code>LPOP</code>命令</h3><p>移除并返回列表 <code>key</code> 的头（最左）元素。</p>
<p>当<code>key</code>不存在时，返回<code>nil</code>。</p>
<ul>
<li><code>sflags</code>：<code>wF</code>，写命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-23"><a href="#命令形式-23" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-23"><a href="#内部实现函数-23" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    popGenericCommand(c,LIST_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RPOP</code> 和 <code>LPOP</code>只是位置不同，功能相同。关于<code>popGenericCommand()</code>的具体命令参考<code>RPOP</code>。</p>
<h3 id="BRPOP命令"><a href="#BRPOP命令" class="headerlink" title="BRPOP命令"></a><code>BRPOP</code>命令</h3><p>它是 <code>RPOP</code> 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 <code>BRPOP</code> 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个 <code>key</code> 参数时，按参数 <code>key</code> 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。</p>
<p>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和<code>等待时长</code>。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的<code>值</code>。</p>
<ul>
<li><code>sflags</code>：<code>ws</code>，写命令，不允许在Lua脚本中执行此函数。</li>
</ul>
<h4 id="命令形式-24"><a href="#命令形式-24" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-24"><a href="#内部实现函数-24" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,LIST_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>阻塞的pop操作统一通过<code>blockingPopGenericCommand</code>处理，只是位置不同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="comment">/* Blocking RPOP/LPOP */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockingPopGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">mstime_t</span> timeout;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令参数中获取客户端设置的过期时间(c-&gt;argv[c-&gt;argc-1] 最后一个参数)，转化成秒的形式</span></span><br><span class="line">    <span class="comment">// 所以可以看出，BRPOP/BLPOP接受的最小单位是秒(SECONDS)</span></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc<span class="number">-1</span>],&amp;timeout,UNIT_SECONDS)</span><br><span class="line">        != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环处理指定的key</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 从db中检查key是否存在</span></span><br><span class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查key的数据类型是否为list</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != OBJ_LIST) &#123;</span><br><span class="line">                addReply(c,shared.wrongtypeerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (listTypeLength(o) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 列表数据长度&gt;0,所以可以直接取数据返回</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Non empty list, this is like a non normal [LR]POP. */</span></span><br><span class="line">                    <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpop"</span> : <span class="string">"rpop"</span>;</span><br><span class="line">                    robj *value = listTypePop(o,where);</span><br><span class="line">                    serverAssert(value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回取出的key和val</span></span><br><span class="line">                    addReplyMultiBulkLen(c,<span class="number">2</span>);</span><br><span class="line">                    addReplyBulk(c,c-&gt;argv[j]);</span><br><span class="line">                    addReplyBulk(c,value);</span><br><span class="line">                    <span class="comment">// 因为已经pop出来了，所以引用次数减1</span></span><br><span class="line">                    decrRefCount(value);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 触发事件</span></span><br><span class="line">                    notifyKeyspaceEvent(NOTIFY_LIST,event,</span><br><span class="line">                                        c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">                    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 判断取出后列表长度，如果已经为0,则删除列表</span></span><br><span class="line">                        dbDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">                        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                                            c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">                    server.dirty++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Replicate it as an [LR]POP instead of B[LR]POP. */</span></span><br><span class="line">                    rewriteClientCommandVector(c,<span class="number">2</span>,</span><br><span class="line">                        (where == LIST_HEAD) ? shared.lpop : shared.rpop,</span><br><span class="line">                        c-&gt;argv[j]);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在事务(CLIENT_MULTI)中使用 BRPOP/BLPOP 没意义，所以把它当做无阻塞处理</span></span><br><span class="line">    <span class="comment">/* If we are inside a MULTI/EXEC and the list is empty the only thing</span></span><br><span class="line"><span class="comment">     * we can do is treating it as a timeout (even with timeout 0). */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReply(c,shared.nullmultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞处理</span></span><br><span class="line">    <span class="comment">/* If the list is empty or the key does not exists we must block */</span></span><br><span class="line">    blockForKeys(c, c-&gt;argv + <span class="number">1</span>, c-&gt;argc - <span class="number">2</span>, timeout, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>blockForKeys()</code>才是阻塞的开始。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="comment">/* Set a client in blocking mode for the specified key, with the specified</span></span><br><span class="line"><span class="comment"> * timeout */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockForKeys</span><span class="params">(client *c, robj **keys, <span class="keyword">int</span> numkeys, <span class="keyword">mstime_t</span> timeout, robj *target)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    c-&gt;bpop.timeout = timeout; <span class="comment">// 为这个客户端连接(client)设置阻塞时间</span></span><br><span class="line">    c-&gt;bpop.target = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">NULL</span>) incrRefCount(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="comment">// 循环处理每个key</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为这个客户端连接(client)的bpop操作添加key</span></span><br><span class="line">        <span class="comment">/* If the key already exists in the dict ignore it. */</span></span><br><span class="line">        <span class="keyword">if</span> (dictAdd(c-&gt;bpop.keys,keys[j],<span class="literal">NULL</span>) != DICT_OK) <span class="keyword">continue</span>;</span><br><span class="line">        incrRefCount(keys[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redis的db中，会维持中一个dict(blocking_keys)来保存被阻塞操作的key</span></span><br><span class="line">        <span class="comment">// 下面则是尝试从这个db的blocking_keys中查找指定的key</span></span><br><span class="line">        <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 阻塞key没有在db中查找到，则添加</span></span><br><span class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></span><br><span class="line">            l = listCreate();</span><br><span class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</span><br><span class="line">            incrRefCount(keys[j]);</span><br><span class="line">            serverAssertWithInfo(c,keys[j],retval == DICT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 阻塞key查找到，从中获取list </span></span><br><span class="line">            l = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将客户端连接保存进list</span></span><br><span class="line">        <span class="comment">// 这个list, 是db中，将阻塞key和对应了客户端连接相关联的list,用来保存这个key被哪些客户端阻塞获取</span></span><br><span class="line">        listAddNodeTail(l,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞客户端</span></span><br><span class="line">    blockClient(c,BLOCKED_LIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>blockClient()</code>将客户端连接阻塞。</p>
<p>对于阻塞连接的过期触发，会被<code>server.c</code>中的<code>clientsCronHandleTimeout()</code>来触发的。</p>
<p>至于<code>key</code>的变动触发，则是通过<code>t_list.c</code>中的<code>handleClientsBlockedOnLists()</code>来触发的，从注释中可以知道，每个单个命令后，Redis都会触发这个函数，或者在<code>MULTI/EXEC</code>和<code>Lua</code>脚本后。</p>
<h3 id="BLPOP命令"><a href="#BLPOP命令" class="headerlink" title="BLPOP命令"></a><code>BLPOP</code>命令</h3><p>它是 <code>LPOP</code> 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 <code>BLPOP</code> 命令阻塞，直到等待超时或发现可弹出元素为止。</p>
<p>当给定多个 <code>key</code> 参数时，按参数 <code>key</code> 的先后顺序依次检查各个列表，弹出第一个非空列表的头部元素。</p>
<p>假如在指定时间内没有任何元素被弹出，则返回一个 <code>nil</code> 和<code>等待时长</code>。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 <code>key</code> ，第二个元素是被弹出元素的<code>值</code>。</p>
<ul>
<li><code>sflags</code>：<code>ws</code>，写命令，不允许在Lua脚本中执行此函数。</li>
</ul>
<h4 id="命令形式-25"><a href="#命令形式-25" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-25"><a href="#内部实现函数-25" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blpopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    blockingPopGenericCommand(c,LIST_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与命令<code>BRPOP</code>只是元素弹出的位置不同,所以详细可以看<code>BRPOP</code>。</p>
<h3 id="BRPOPLPUSH命令"><a href="#BRPOPLPUSH命令" class="headerlink" title="BRPOPLPUSH命令"></a><code>BRPOPLPUSH</code>命令</h3><p><code>BRPOPLPUSH</code> 是 <code>RPOPLPUSH</code> 的阻塞版本，当给定列表 <code>source</code> 不为空时， <code>BRPOPLPUSH</code> 的表现和 <code>RPOPLPUSH</code> 一样。</p>
<p>命令 <code>BRPOPLPUSH</code> 执行以下两个动作：</p>
<ul>
<li>将列表 <code>source</code> 中的最后一个元素(尾元素)弹出，并返回给客户端。</li>
<li>将 <code>source</code> 弹出的元素插入到列表 <code>destination</code> ，作为 <code>destination</code> 列表的的头元素。</li>
</ul>
<p>当列表 <code>source</code> 为空时， <code>BRPOPLPUSH</code> 命令将阻塞连接，直到等待超时，或有另一个客户端对 <code>source</code> 执行 <code>LPUSH</code> 或 <code>RPUSH</code> 命令为止。</p>
<p>超时参数 <code>timeout</code> 接受一个以秒为单位的数字作为值。超时参数设为 <code>0</code> 表示阻塞时间可以无限期延长(block indefinitely) 。</p>
<p>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。<br>反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</p>
<ul>
<li><code>sflags</code>：<code>wms</code>，写命令，可能改变内存使用，不允许在Lua脚本中执行此函数。</li>
</ul>
<h4 id="命令形式-26"><a href="#命令形式-26" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BRPOPLPUSH source destination timeout</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-26"><a href="#内部实现函数-26" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">brpoplpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令参数中解析出timeout秒数</span></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;timeout,UNIT_SECONDS)</span><br><span class="line">        != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出source对应的key</span></span><br><span class="line">    robj *key = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// source对应的key不存在 </span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">            <span class="comment">// 事务不支持阻塞(Block)</span></span><br><span class="line">            <span class="comment">/* Blocking against an empty list in a multi state</span></span><br><span class="line"><span class="comment">             * returns immediately. */</span></span><br><span class="line">            addReply(c, shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// c-&gt;argv + 1 是 source,  c-&gt;argv[2] 是 destination</span></span><br><span class="line">            <span class="comment">/* The list is empty and the client blocks. */</span></span><br><span class="line">            blockForKeys(c, c-&gt;argv + <span class="number">1</span>, <span class="number">1</span>, timeout, c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key-&gt;type != OBJ_LIST) &#123;</span><br><span class="line">            addReply(c, shared.wrongtypeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// source存在且有值(默认情况下, 没值的list类型会被删除)</span></span><br><span class="line">            <span class="comment">/* The list exists and has elements, so</span></span><br><span class="line"><span class="comment">             * the regular rpoplpushCommand is executed. */</span></span><br><span class="line">            serverAssertWithInfo(c,key,listTypeLength(key) &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 直接调用 rpoplpushCommand() 不需要阻塞 </span></span><br><span class="line">            rpoplpushCommand(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>blockForKeys()</code>可以参考<code>BRPOP</code>中的内容。</li>
<li>对于<code>rpoplpushCommand()</code>可以参考<code>RPOPLPUSH</code>的内容。</li>
</ul>
<h3 id="LLEN命令"><a href="#LLEN命令" class="headerlink" title="LLEN命令"></a><code>LLEN</code>命令</h3><p>返回列表 key 的长度。</p>
<p>如果 key 不存在，则 key 被解释为一个空列表，返回 0 .</p>
<p>如果 key 不是列表类型，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>,只读操作。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-27"><a href="#命令形式-27" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-27"><a href="#内部实现函数-27" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llenCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试在db中取出key, 并判断类型</span></span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取list类型的长度(其实，list类型的实现只剩下quick list了)</span></span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list</span></span><br><span class="line"><span class="comment">// 获取list类型的对象长度(只剩下quick list)</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">listTypeLength</span><span class="params">(<span class="keyword">const</span> robj *subject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="keyword">return</span> quicklistCount(subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LINDEX命令"><a href="#LINDEX命令" class="headerlink" title="LINDEX命令"></a><code>LINDEX</code>命令</h3><p>返回列表 <code>key</code> 中，下标为 <code>index</code> 的元素。</p>
<p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 <code>0</code> 为底，也就是说，以 <code>0</code> 表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</p>
<p>如果 <code>key</code> 不是列表类型，返回一个错误。</p>
<p>如果 <code>index</code> 参数的值不在列表的区间范围内(out of range)，返回 <code>nil</code>。</p>
<ul>
<li><code>sflags</code>：<code>r</code>,只读命令。</li>
</ul>
<h4 id="命令形式-28"><a href="#命令形式-28" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-28"><a href="#内部实现函数-28" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lindexCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从db中查找key并判断类型</span></span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令参数中获取index</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list的实现，只剩下quick list</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklistEntry entry;</span><br><span class="line">        <span class="keyword">if</span> (quicklistIndex(o-&gt;ptr, index, &amp;entry)) &#123;</span><br><span class="line">            <span class="comment">// 从quicklist中取出对应index的entry</span></span><br><span class="line">            <span class="keyword">if</span> (entry.value) &#123;</span><br><span class="line">                <span class="comment">// 新建value字符类型</span></span><br><span class="line">                value = createStringObject((<span class="keyword">char</span>*)entry.value,entry.sz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 新建value整型类型</span></span><br><span class="line">                value = createStringObjectFromLongLong(entry.longval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回</span></span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            <span class="comment">// 减少value的引用次数(因为create的时候会默认置为1或者增1)</span></span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LSET命令"><a href="#LSET命令" class="headerlink" title="LSET命令"></a><code>LSET</code>命令</h3><p>将列表 <code>key</code> 下标为 <code>index</code> 的元素的值设置为 <code>value</code> 。</p>
<p>当 <code>index</code> 参数超出范围，或对一个空列表( <code>key</code> 不存在)进行 <code>LSET</code> 时，返回一个错误。</p>
<p>操作成功返回 <code>ok</code> ，否则返回错误信息。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>,写命令，并可能导致增加内存的使用。</li>
</ul>
<h4 id="命令形式-29"><a href="#命令形式-29" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-29"><a href="#内部实现函数-29" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的key,并判断类型</span></span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nokeyerr);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    robj *value = c-&gt;argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令中获取参数index</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list的实现，只剩下quick list</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        quicklist *ql = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 调用快速列表的方法来替换元素</span></span><br><span class="line">        <span class="keyword">int</span> replaced = quicklistReplaceAtIndex(ql, index,</span><br><span class="line">                                               value-&gt;ptr, sdslen(value-&gt;ptr));</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            <span class="comment">// 替换失败</span></span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回成功</span></span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            <span class="comment">// 标记key改变和触发事件</span></span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">"lset"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LRANGE命令"><a href="#LRANGE命令" class="headerlink" title="LRANGE命令"></a><code>LRANGE</code>命令</h3><p>返回列表 <code>key</code> 中指定区间内的元素，区间以偏移量 <code>start</code> 和 <code>stop</code> 指定。</p>
<p>下标(index)参数 <code>start</code> 和 <code>stop</code> 都以 <code>0</code> 为底，也就是说，以 <code>0</code> 表示列表的第一个元素，以 <code>1</code> 表示列表的第二个元素，以此类推。</p>
<p>你也可以使用负数下标，以 <code>-1</code> 表示列表的最后一个元素， <code>-2</code> 表示列表的倒数第二个元素，以此类推。</p>
<p><strong>超出范围的下标</strong></p>
<p>超出范围的下标值不会引起错误。</p>
<p>如果 <code>start</code> 下标比列表的最大下标 <code>end</code> ( <code>LLEN list</code> 减去 <code>1</code> )还要大，那么 <code>LRANGE</code> 返回一个空列表。</p>
<p>如果 <code>stop</code> 下标比 <code>end</code> 下标还要大，Redis将 <code>stop</code> 的值设置为 <code>end</code> 。</p>
<ul>
<li><code>sflags</code>：<code>r</code>,只读命令。</li>
</ul>
<h4 id="命令形式-30"><a href="#命令形式-30" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-30"><a href="#内部实现函数-30" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrangeCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中获取 start 和 end 的值</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取和判断key的类型</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key对应list的长度</span></span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算范围..</span></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyMultiBulkLen(c,rangelen);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 获取list的迭代器</span></span><br><span class="line">        listTypeIterator *iter = listTypeInitIterator(o, start, LIST_TAIL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代获取list中的值</span></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            listTypeEntry entry;</span><br><span class="line">            listTypeNext(iter, &amp;entry);</span><br><span class="line">            quicklistEntry *qe = &amp;entry.entry;</span><br><span class="line">            <span class="keyword">if</span> (qe-&gt;value) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,qe-&gt;value,qe-&gt;sz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,qe-&gt;longval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"List encoding is not QUICKLIST!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LTRIM命令"><a href="#LTRIM命令" class="headerlink" title="LTRIM命令"></a><code>LTRIM</code>命令</h3><p>让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>
<ul>
<li><code>sflags</code>：<code>w</code>,写命令。</li>
</ul>
<h4 id="命令形式-31"><a href="#命令形式-31" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTRIM key start stop</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-31"><a href="#内部实现函数-31" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ltrimCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, llen, ltrim, rtrim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令参数中获取start/stop偏移量</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的key并判断类型</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相对的start/stop转换成绝对的</span></span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        ltrim = start;</span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ltrim: 左边开始删除几个元素</span></span><br><span class="line">    <span class="comment">// rtrim: 右边开始删除几个元素</span></span><br><span class="line">    <span class="comment">/* Remove list elements to perform the trim */</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// quicklistDelRange(quicklist *quicklist, const long start, const long count)</span></span><br><span class="line">        <span class="comment">// 所以quicklistDelRange是从start开始，删除count个</span></span><br><span class="line">        quicklistDelRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        quicklistDelRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发键空间改变事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">"ltrim"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// list 中没有数据, 删除</span></span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LREM命令"><a href="#LREM命令" class="headerlink" title="LREM命令"></a><code>LREM</code>命令</h3><p>根据参数 <code>count</code> 的值，移除列表中与参数 <code>value</code> 相等的元素。</p>
<p><code>count</code> 的值可以是以下几种：</p>
<ul>
<li><code>count</code> &gt; 0 : 从表头开始向表尾搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 。</li>
<li><code>count</code> &lt; 0 : 从表尾开始向表头搜索，移除与 <code>value</code> 相等的元素，数量为 <code>count</code> 的绝对值。</li>
<li><code>count</code> = 0 : 移除表中所有与 <code>value</code> 相等的值。</li>
</ul>
<ul>
<li><code>sflags</code>：<code>w</code>,写命令。</li>
</ul>
<h4 id="命令形式-32"><a href="#命令形式-32" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-32"><a href="#内部实现函数-32" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lremCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">long</span> toremove;</span><br><span class="line">    <span class="keyword">long</span> removed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中获取要删除的元素个数toremove</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;toremove, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中获取key,并判断类型</span></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器</span></span><br><span class="line">    <span class="comment">// listTypeInitIterator()其实只是封装了quick list的迭代器</span></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,LIST_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,LIST_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代元素并删除对应数量(toremove)指定的值(obj)</span></span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(li, &amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">        <span class="comment">// 如果成功删除元素,触发事件</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">"lrem"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list为空,直接删除</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPOPLPUSH命令"><a href="#RPOPLPUSH命令" class="headerlink" title="RPOPLPUSH命令"></a><code>RPOPLPUSH</code>命令</h3><p>命令 <code>RPOPLPUSH</code> 在一个原子时间内，执行以下两个动作：</p>
<p>将列表 <code>source</code> 中的最后一个元素(尾元素)弹出，并返回给客户端。<br>将 <code>source</code> 弹出的元素插入到列表 <code>destination</code> ，作为 <code>destination</code> 列表的的头元素。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>,写命令,并可能导致内存使用增加。</li>
</ul>
<h4 id="命令形式-33"><a href="#命令形式-33" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-33"><a href="#内部实现函数-33" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_list.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rpoplpushCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *sobj, *value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中获取指定的 source key</span></span><br><span class="line">    <span class="keyword">if</span> ((sobj = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,sobj,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个key的list长度为0,一般情况下不会出现,具体场景可以看下面的注释</span></span><br><span class="line">        <span class="comment">/* This may only happen after loading very old RDB files. Recent</span></span><br><span class="line"><span class="comment">         * versions of Redis delete keys of empty lists. */</span></span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从命令中获取指定的 destination key</span></span><br><span class="line">        robj *dobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        robj *touchedkey = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 destination key 的类型</span></span><br><span class="line">        <span class="comment">// PS:checkType()返回0表示 是指定类型</span></span><br><span class="line">        <span class="keyword">if</span> (dobj &amp;&amp; checkType(c,dobj,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 从 source key 末尾获取元素 value</span></span><br><span class="line">        value = listTypePop(sobj,LIST_TAIL);</span><br><span class="line">        <span class="comment">/* We saved touched key, and protect it, since rpoplpushHandlePush</span></span><br><span class="line"><span class="comment">         * may change the client command argument vector (it does not</span></span><br><span class="line"><span class="comment">         * currently). */</span></span><br><span class="line">        incrRefCount(touchedkey);</span><br><span class="line">        <span class="comment">// 插入 destination key 的列表头</span></span><br><span class="line">        rpoplpushHandlePush(c,c-&gt;argv[<span class="number">2</span>],dobj,value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* listTypePop returns an object with its refcount incremented */</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the source list when it is empty */</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,<span class="string">"rpop"</span>,touchedkey,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">            dbDelete(c-&gt;db,touchedkey);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                                touchedkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,touchedkey);</span><br><span class="line">        decrRefCount(touchedkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == brpoplpushCommand) &#123;</span><br><span class="line">            rewriteClientCommandVector(c,<span class="number">3</span>,shared.rpoplpush,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SADD命令"><a href="#SADD命令" class="headerlink" title="SADD命令"></a><code>SADD</code>命令</h3><p>将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中，已经存在于集合的 <code>member</code> 元素将被忽略。</p>
<p>假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>
<p>当 <code>key</code> 不是集合类型时，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wmF</code>,写命令,并可能导致内存使用增加。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-34"><a href="#命令形式-34" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-34"><a href="#内部实现函数-34" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从命令中获取想要设置的set的key</span></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果set是NULL, 那么根据第一个元素的类型, 返回一个Set</span></span><br><span class="line">        <span class="comment">// 主要有2中Set, Integer和Str</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        <span class="comment">// 添加到db中</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// set已经存在,判断类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将命令中的元素存入set, 并统计成功添加的个数added</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        <span class="comment">// 触发事件</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"sadd"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added;</span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SREM命令"><a href="#SREM命令" class="headerlink" title="SREM命令"></a><code>SREM</code>命令</h3><p>移除集合 <code>key</code> 中的一个或多个 <code>member</code> 元素，不存在的 <code>member</code> 元素会被忽略。</p>
<p>当 <code>key</code> 不是集合类型，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wF</code>,写命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-35"><a href="#命令形式-35" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-35"><a href="#内部实现函数-35" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要移除元素的Set key并判断类型</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次在set中删除命令中的key</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setTypeRemove(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) &#123;</span><br><span class="line">            deleted++;</span><br><span class="line">            <span class="keyword">if</span> (setTypeSize(<span class="built_in">set</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果set已经是空了，直接删除set</span></span><br><span class="line">                dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">                keyremoved = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"srem"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty += deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SMOVE命令"><a href="#SMOVE命令" class="headerlink" title="SMOVE命令"></a><code>SMOVE</code>命令</h3><p>将 <code>member</code> 元素从 <code>source</code> 集合移动到 <code>destination</code> 集合。</p>
<p><code>SMOVE</code> 是原子性操作。</p>
<p>如果 <code>source</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 <code>SMOVE</code> 命令不执行任何操作，仅返回 <code>0</code> 。否则， <code>member</code> 元素从 <code>source</code> 集合中被移除，并添加到 <code>destination</code> 集合中去。</p>
<p>当 <code>destination</code> 集合已经包含 <code>member</code> 元素时， <code>SMOVE</code> 命令只是简单地将 <code>source</code> 集合中的 <code>member</code> 元素删除。</p>
<p>当 <code>source</code> 或 <code>destination</code> 不是集合类型时，返回一个错误。</p>
<ul>
<li><code>sflags</code>：<code>wF</code>,写命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-36"><a href="#命令形式-36" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-36"><a href="#内部实现函数-36" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smoveCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *srcset, *dstset, *ele;</span><br><span class="line">    srcset = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    dstset = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    ele = c-&gt;argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查source key是否存在</span></span><br><span class="line">    <span class="comment">/* If the source key does not exist return 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (srcset == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查source key和destination key的类型(destination key允许为NULL)</span></span><br><span class="line">    <span class="comment">/* If the source key has the wrong type, or the destination key</span></span><br><span class="line"><span class="comment">     * is set and has the wrong type, return with an error. */</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,srcset,OBJ_SET) ||</span><br><span class="line">        (dstset &amp;&amp; checkType(c,dstset,OBJ_SET))) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果source key和destination key是同一个Set,那么元素不需要移动,但需要检查元素ele是否真的在Set中</span></span><br><span class="line">    <span class="comment">/* If srcset and dstset are equal, SMOVE is a no-op */</span></span><br><span class="line">    <span class="keyword">if</span> (srcset == dstset) &#123;</span><br><span class="line">        addReply(c,setTypeIsMember(srcset,ele-&gt;ptr) ?</span><br><span class="line">            shared.cone : shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ele不能从source key中删除,说明ele不存在于source key</span></span><br><span class="line">    <span class="comment">/* If the element cannot be removed from the src set, return 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (!setTypeRemove(srcset,ele-&gt;ptr)) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"srem"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查source key的大小, 为0则删除key</span></span><br><span class="line">    <span class="comment">/* Remove the src set from the database when empty */</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeSize(srcset) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要创建destination key</span></span><br><span class="line">    <span class="comment">/* Create the destination set when it doesn't exist */</span></span><br><span class="line">    <span class="keyword">if</span> (!dstset) &#123;</span><br><span class="line">        dstset = setTypeCreate(ele-&gt;ptr);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">2</span>],dstset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将ele添加到destination key中</span></span><br><span class="line">    <span class="comment">/* An extra key has changed when ele was successfully added to dstset */</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeAdd(dstset,ele-&gt;ptr)) &#123;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"sadd"</span>,c-&gt;argv[<span class="number">2</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    addReply(c,shared.cone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SISMEMBER命令"><a href="#SISMEMBER命令" class="headerlink" title="SISMEMBER命令"></a><code>SISMEMBER</code>命令</h3><p>判断 <code>member</code> 元素是否集合 <code>key</code> 的成员。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>,读命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-37"><a href="#命令形式-37" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-37"><a href="#内部实现函数-37" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sismemberCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查Set key是否存在并判断类型</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断元素是否在Set中</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeIsMember(<span class="built_in">set</span>,c-&gt;argv[<span class="number">2</span>]-&gt;ptr))</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SCARD命令"><a href="#SCARD命令" class="headerlink" title="SCARD命令"></a><code>SCARD</code>命令</h3><p>返回集合 <code>key</code> 中元素的数量。</p>
<ul>
<li><code>sflags</code>：<code>rF</code>,读命令。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-38"><a href="#命令形式-38" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-38"><a href="#内部实现函数-38" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setTypeSize()封装了hash table和int set的获取size方法</span></span><br><span class="line">    addReplyLongLong(c,setTypeSize(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPOP命令"><a href="#SPOP命令" class="headerlink" title="SPOP命令"></a><code>SPOP</code>命令</h3><p>移除并返回集合 <code>key</code> 中的一个或者多个随机元素。</p>
<ul>
<li><code>sflags</code>：<code>wRF</code>, 写命令，并且是随机的。快速执行，不应该被延迟。</li>
</ul>
<h4 id="命令形式-39"><a href="#命令形式-39" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-39"><a href="#内部实现函数-39" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>主要分为两个函数：</p>
<ul>
<li><code>spopCommand()</code>处理随机移出<code>1</code>个;</li>
<li><code>spopWithCountCommand()</code>处理随机移出<code>count</code>个;</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>, *ele, *aux;</span><br><span class="line">    sds sdsele;</span><br><span class="line">    <span class="keyword">int64_t</span> llele;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果命令中带有count参数，则交给`spopWithCountCommand()`处理</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        spopWithCountCommand(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 命令语法错误</span></span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key并判断是否存在和类型</span></span><br><span class="line">    <span class="comment">/* Make sure a key with the name inputted exists, and that it's type is</span></span><br><span class="line"><span class="comment">     * indeed a set */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在set中获取一个随机元素(详细随机的实现没看)</span></span><br><span class="line">    <span class="comment">/* Get a random element from the set */</span></span><br><span class="line">    encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;sdsele,&amp;llele);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断set的编码类型</span></span><br><span class="line">    <span class="comment">/* Remove the element from the set */</span></span><br><span class="line">    <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="comment">// 移出元素</span></span><br><span class="line">        ele = createStringObjectFromLongLong(llele);</span><br><span class="line">        <span class="built_in">set</span>-&gt;ptr = intsetRemove(<span class="built_in">set</span>-&gt;ptr,llele,<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 移出元素</span></span><br><span class="line">        <span class="comment">// setTypeRemove()其实是支持OBJ_ENCODING_INTSET的</span></span><br><span class="line">        <span class="comment">// 但传入的值类型是sds, 所以上面直接调用了intsetRemove()</span></span><br><span class="line">        ele = createStringObject(sdsele,sdslen(sdsele));</span><br><span class="line">        setTypeRemove(<span class="built_in">set</span>,ele-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"spop"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于这个删除元素实现，使用SREM写到AOF/复制中(因为SPOP是随机的，不幂等的)</span></span><br><span class="line">    <span class="comment">/* Replicate/AOF this command as an SREM operation */</span></span><br><span class="line">    aux = createStringObject(<span class="string">"SREM"</span>,<span class="number">4</span>);</span><br><span class="line">    rewriteClientCommandVector(c,<span class="number">3</span>,aux,c-&gt;argv[<span class="number">1</span>],ele);</span><br><span class="line">    decrRefCount(aux);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the element to the reply */</span></span><br><span class="line">    addReplyBulk(c,ele);</span><br><span class="line">    decrRefCount(ele);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Set的大小,为0则直接删除</span></span><br><span class="line">    <span class="comment">/* Delete the set if it's empty */</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeSize(<span class="built_in">set</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set has been modified */</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="comment">/* Handle the "SPOP key &lt;count&gt;" variant. The normal version of the</span></span><br><span class="line"><span class="comment"> * command is handled by the spopCommand() function itself. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* How many times bigger should be the set compared to the remaining size</span></span><br><span class="line"><span class="comment"> * for us to use the "create new set" strategy? Read later in the</span></span><br><span class="line"><span class="comment"> * implementation for more info. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPOP_MOVE_STRATEGY_MUL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于带count参数的SPOP命令处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spopWithCountCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count, size;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数count</span></span><br><span class="line">    <span class="comment">/* Get the count argument */</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;l,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        count = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.outofrangeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的Set key并判断类型</span></span><br><span class="line">    <span class="comment">/* Make sure a key with the name inputted exists, and that it's type is</span></span><br><span class="line"><span class="comment">     * indeed a set. Otherwise, return nil */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk))</span><br><span class="line">        == <span class="literal">NULL</span> || checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If count is zero, serve an empty multibulk ASAP to avoid special</span></span><br><span class="line"><span class="comment">     * cases later. */</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// size为set的原本大小</span></span><br><span class="line">    size = setTypeSize(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate an SPOP keyspace notification */</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"spop"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty += count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 1:</span></span><br><span class="line"><span class="comment">     * The number of requested elements is greater than or equal to</span></span><br><span class="line"><span class="comment">     * the number of elements inside the set: simply return the whole set. */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// 直接返回整个set</span></span><br><span class="line">        <span class="comment">/* We just return the entire set */</span></span><br><span class="line">        sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,<span class="number">1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除这个set</span></span><br><span class="line">        <span class="comment">/* Delete the set as it is now empty */</span></span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写删除到命令</span></span><br><span class="line">        <span class="comment">/* Propagate this command as an DEL operation */</span></span><br><span class="line">        rewriteClientCommandVector(c,<span class="number">2</span>,shared.del,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里propargv[]是构造了一个写到AOF等的参数数据,[0]是SREM命令,[1]是指定的key</span></span><br><span class="line">    <span class="comment">/* Case 2 and 3 require to replicate SPOP as a set of SREM commands.</span></span><br><span class="line"><span class="comment">     * Prepare our replication argument vector. Also send the array length</span></span><br><span class="line"><span class="comment">     * which is common to both the code paths. */</span></span><br><span class="line">    robj *propargv[<span class="number">3</span>];</span><br><span class="line">    propargv[<span class="number">0</span>] = createStringObject(<span class="string">"SREM"</span>,<span class="number">4</span>);</span><br><span class="line">    propargv[<span class="number">1</span>] = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    addReplyMultiBulkLen(c,count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Common iteration vars. */</span></span><br><span class="line">    sds sdsele;</span><br><span class="line">    robj *objele;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line">    <span class="keyword">int64_t</span> llele;</span><br><span class="line">    <span class="comment">// remaining SPOP后, Set最终会剩余的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> remaining = size-count; <span class="comment">/* Elements left after SPOP. */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下两个方法:</span></span><br><span class="line">    <span class="comment">//    1.直接在Set中循环删除随机count个元素 </span></span><br><span class="line">    <span class="comment">//    2.随机抽取remaining个元素,组成新的Set并保存指定的key中,然后将旧的返回</span></span><br><span class="line">    <span class="comment">// remaining*SPOP_MOVE_STRATEGY_MUL相当于一个比例参数（魔法数字？）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are here, the number of requested elements is less than the</span></span><br><span class="line"><span class="comment">     * number of elements inside the set. Also we are sure that count &lt; size.</span></span><br><span class="line"><span class="comment">     * Use two different strategies.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * CASE 2: The number of elements to return is small compared to the</span></span><br><span class="line"><span class="comment">     * set size. We can just extract random elements and return them to</span></span><br><span class="line"><span class="comment">     * the set. */</span></span><br><span class="line">    <span class="keyword">if</span> (remaining*SPOP_MOVE_STRATEGY_MUL &gt; count) &#123;</span><br><span class="line">        <span class="comment">// 直接在Set中循环删除随机count个元素 </span></span><br><span class="line">        <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">            <span class="comment">/* Emit and remove. */</span></span><br><span class="line">            encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;sdsele,&amp;llele);</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                addReplyBulkLongLong(c,llele);</span><br><span class="line">                objele = createStringObjectFromLongLong(llele);</span><br><span class="line">                <span class="built_in">set</span>-&gt;ptr = intsetRemove(<span class="built_in">set</span>-&gt;ptr,llele,<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));</span><br><span class="line">                objele = createStringObject(sdsele,sdslen(sdsele));</span><br><span class="line">                setTypeRemove(<span class="built_in">set</span>,sdsele);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Replicate/AOF this command as an SREM operation */</span></span><br><span class="line">            propargv[<span class="number">2</span>] = objele;</span><br><span class="line">            alsoPropagate(server.sremCommand,c-&gt;db-&gt;id,propargv,<span class="number">3</span>,</span><br><span class="line">                PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">            decrRefCount(objele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* CASE 3: The number of elements to return is very big, approaching</span></span><br><span class="line"><span class="comment">     * the size of the set itself. After some time extracting random elements</span></span><br><span class="line"><span class="comment">     * from such a set becomes computationally expensive, so we use</span></span><br><span class="line"><span class="comment">     * a different strategy, we extract random elements that we don't</span></span><br><span class="line"><span class="comment">     * want to return (the elements that will remain part of the set),</span></span><br><span class="line"><span class="comment">     * creating a new set as we do this (that will be stored as the original</span></span><br><span class="line"><span class="comment">     * set). Then we return the elements left in the original set and</span></span><br><span class="line"><span class="comment">     * release it. */</span></span><br><span class="line">     <span class="comment">// 随机抽取remaining个元素,组成新的Set并保存指定的key中,然后将旧的返回</span></span><br><span class="line">        robj *newset = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Create a new set with just the remaining elements. */</span></span><br><span class="line">        <span class="keyword">while</span>(remaining--) &#123;</span><br><span class="line">            encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;sdsele,&amp;llele);</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                sdsele = sdsfromlonglong(llele);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sdsele = sdsdup(sdsele);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!newset) newset = setTypeCreate(sdsele);</span><br><span class="line">            setTypeAdd(newset,sdsele);</span><br><span class="line">            setTypeRemove(<span class="built_in">set</span>,sdsele);</span><br><span class="line">            sdsfree(sdsele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Assign the new set as the key value. */</span></span><br><span class="line">        incrRefCount(<span class="built_in">set</span>); <span class="comment">/* Protect the old set value. */</span></span><br><span class="line">        dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],newset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Tranfer the old set to the client and release it. */</span></span><br><span class="line">        setTypeIterator *si;</span><br><span class="line">        si = setTypeInitIterator(<span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;sdsele,&amp;llele)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                addReplyBulkLongLong(c,llele);</span><br><span class="line">                objele = createStringObjectFromLongLong(llele);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));</span><br><span class="line">                objele = createStringObject(sdsele,sdslen(sdsele));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Replicate/AOF this command as an SREM operation */</span></span><br><span class="line">            propargv[<span class="number">2</span>] = objele;</span><br><span class="line">            alsoPropagate(server.sremCommand,c-&gt;db-&gt;id,propargv,<span class="number">3</span>,</span><br><span class="line">                PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">            decrRefCount(objele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        decrRefCount(<span class="built_in">set</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't propagate the command itself even if we incremented the</span></span><br><span class="line"><span class="comment">     * dirty counter. We don't want to propagate an SPOP command since</span></span><br><span class="line"><span class="comment">     * we propagated the command as a set of SREMs operations using</span></span><br><span class="line"><span class="comment">     * the alsoPropagate() API. */</span></span><br><span class="line">    decrRefCount(propargv[<span class="number">0</span>]);</span><br><span class="line">    preventCommandPropagation(c);</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SRANDMEMBER命令"><a href="#SRANDMEMBER命令" class="headerlink" title="SRANDMEMBER命令"></a><code>SRANDMEMBER</code>命令</h3><p>如果命令执行时，只提供了 <code>key</code> 参数，那么返回集合中的一个随机元素。</p>
<p>如果 <code>count</code> 为正数，且小于集合基数，那么命令返回一个包含 <code>count</code> 个元素的数组，数组中的元素各不相同。如果 <code>count</code> 大于等于集合基数，那么返回整个集合。<br>如果 <code>count</code> 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 <code>count</code> 的绝对值。</p>
<ul>
<li><code>sflags</code>：<code>rR</code>,读命令，而且随机不幂等。</li>
</ul>
<h4 id="命令形式-40"><a href="#命令形式-40" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-40"><a href="#内部实现函数-40" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>主要分为两个函数：</p>
<ul>
<li><code>srandmemberCommand()</code>处理随机返回<code>1</code>个;</li>
<li><code>srandmemberWithCountCommand()</code>处理随机返回<code>count</code>个;</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int64_t</span> llele;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 当存在count参数时,交由srandmemberWithCountCommand()处理</span></span><br><span class="line">        srandmemberWithCountCommand(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的Set key并判断类型</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机取出一个元素并返回Set的编码类型</span></span><br><span class="line">    encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;ele,&amp;llele);</span><br><span class="line">    <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">        addReplyBulkLongLong(c,llele);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="comment">/* handle the "SRANDMEMBER key &lt;count&gt;" variant. The normal version of the</span></span><br><span class="line"><span class="comment"> * command is handled by the srandmemberCommand() function itself. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* How many times bigger should be the set compared to the requested size</span></span><br><span class="line"><span class="comment"> * for us to don't use the "remove elements" strategy? Read later in the</span></span><br><span class="line"><span class="comment"> * implementation for more info. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRANDMEMBER_SUB_STRATEGY_MUL 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srandmemberWithCountCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count, size;</span><br><span class="line">    <span class="keyword">int</span> uniq = <span class="number">1</span>;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int64_t</span> llele;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    dict *d;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取返回格式count和uniq(用于标识是否返回重复数据, 1: 不重复  0: 重复)</span></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;l,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        count = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) l;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* A negative count means: return the same elements multiple times</span></span><br><span class="line"><span class="comment">         * (i.e. don't remove the extracted element after every extraction). */</span></span><br><span class="line">        count = -l;</span><br><span class="line">        uniq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定的Set key并判断是否存在和类型</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk))</span><br><span class="line">        == <span class="literal">NULL</span> || checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line">    size = setTypeSize(<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If count is zero, serve it ASAP to avoid special cases later. */</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// uniq == 0, 允许返回重复的数据，所以简单执行count次就可以了</span></span><br><span class="line">    <span class="comment">/* CASE 1: The count was negative, so the extraction method is just:</span></span><br><span class="line"><span class="comment">     * "return N random elements" sampling the whole set every time.</span></span><br><span class="line"><span class="comment">     * This case is trivial and can be served without auxiliary data</span></span><br><span class="line"><span class="comment">     * structures. */</span></span><br><span class="line">    <span class="keyword">if</span> (!uniq) &#123;</span><br><span class="line">        addReplyMultiBulkLen(c,count);</span><br><span class="line">        <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">            encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;ele,&amp;llele);</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                addReplyBulkLongLong(c,llele);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但cout &gt;= size,需要返回的数量大于size数，而且又不重复</span></span><br><span class="line">    <span class="comment">// 直接返回这个set就可以了</span></span><br><span class="line">    <span class="comment">/* CASE 2:</span></span><br><span class="line"><span class="comment">     * The number of requested elements is greater than the number of</span></span><br><span class="line"><span class="comment">     * elements inside the set: simply return the whole set. */</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= size) &#123;</span><br><span class="line">        sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,<span class="number">1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后面的case,需要一个字典来保存</span></span><br><span class="line">    <span class="comment">/* For CASE 3 and CASE 4 we need an auxiliary dictionary. */</span></span><br><span class="line">    d = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩下两个方法:</span></span><br><span class="line">    <span class="comment">//    case 3: 由于指定的count很大(但小于size),所以直接将set保存到字典d中，然后随机删除size-count个元素</span></span><br><span class="line">    <span class="comment">//    case 4:  由于指定的count相对于size很小(但小于size),所以直接随机在set中读取元素，保存到字典d中，直到d的大小达到count</span></span><br><span class="line">    <span class="comment">// count*SRANDMEMBER_SUB_STRATEGY_MUL相当于一个比例参数（魔法数字？）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 3:</span></span><br><span class="line"><span class="comment">     * The number of elements inside the set is not greater than</span></span><br><span class="line"><span class="comment">     * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.</span></span><br><span class="line"><span class="comment">     * In this case we create a set from scratch with all the elements, and</span></span><br><span class="line"><span class="comment">     * subtract random elements to reach the requested number of elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This is done because if the number of requsted elements is just</span></span><br><span class="line"><span class="comment">     * a bit less than the number of elements in the set, the natural approach</span></span><br><span class="line"><span class="comment">     * used into CASE 3 is highly inefficient. */</span></span><br><span class="line">    <span class="keyword">if</span> (count*SRANDMEMBER_SUB_STRATEGY_MUL &gt; size) &#123;</span><br><span class="line">        setTypeIterator *si;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Add all the elements into the temporary dictionary. */</span></span><br><span class="line">        si = setTypeInitIterator(<span class="built_in">set</span>);</span><br><span class="line">        <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;ele,&amp;llele)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval = DICT_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                retval = dictAdd(d,createStringObjectFromLongLong(llele),<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                retval = dictAdd(d,createStringObject(ele,sdslen(ele)),<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            serverAssert(retval == DICT_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        serverAssert(dictSize(d) == size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除size-count个元素</span></span><br><span class="line">        <span class="comment">/* Remove random elements to reach the right count. */</span></span><br><span class="line">        <span class="keyword">while</span>(size &gt; count) &#123;</span><br><span class="line">            dictEntry *de;</span><br><span class="line"></span><br><span class="line">            de = dictGetRandomKey(d);</span><br><span class="line">            dictDelete(d,dictGetKey(de));</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 4: We have a big set compared to the requested number of elements.</span></span><br><span class="line"><span class="comment">     * In this case we can simply get random elements from the set and add</span></span><br><span class="line"><span class="comment">     * to the temporary set, trying to eventually get enough unique elements</span></span><br><span class="line"><span class="comment">     * to reach the specified count. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> added = <span class="number">0</span>;</span><br><span class="line">        robj *objele;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(added &lt; count) &#123;</span><br><span class="line">            encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;ele,&amp;llele);</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                objele = createStringObjectFromLongLong(llele);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                objele = createStringObject(ele,sdslen(ele));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Try to add the object to the dictionary. If it already exists</span></span><br><span class="line"><span class="comment">             * free it, otherwise increment the number of objects we have</span></span><br><span class="line"><span class="comment">             * in the result dictionary. */</span></span><br><span class="line">            <span class="keyword">if</span> (dictAdd(d,objele,<span class="literal">NULL</span>) == DICT_OK)</span><br><span class="line">                added++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                decrRefCount(objele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 3 &amp; 4: send the result to the user. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        dictIterator *di;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        addReplyMultiBulkLen(c,count);</span><br><span class="line">        di = dictGetIterator(d);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>)</span><br><span class="line">            addReplyBulk(c,dictGetKey(de));</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        dictRelease(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SINTER命令"><a href="#SINTER命令" class="headerlink" title="SINTER命令"></a><code>SINTER</code>命令</h3><p>返回一个集合的全部成员，该集合是所有给定集合的交集。</p>
<p>不存在的 <code>key</code> 被视为空集。</p>
<p>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</p>
<ul>
<li><code>sflags</code>：<code>rS</code>,读命令，具有幂等性。</li>
</ul>
<h4 id="命令形式-41"><a href="#命令形式-41" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-41"><a href="#内部实现函数-41" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体实现，其实交由<code>sinterGenericCommand()</code>，与命令<code>SINTERSTORE</code>相同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterGenericCommand</span><span class="params">(client *c, robj **setkeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">unsigned</span> <span class="keyword">long</span> setnum, robj *dstkey)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds elesds;</span><br><span class="line">    <span class="keyword">int64_t</span> intobj;</span><br><span class="line">    <span class="keyword">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            <span class="comment">// 处理不存在的key, 当成空集,直接返回空</span></span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="comment">// 如果有dstkey,则尝试在db中删除</span></span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptymultibulk);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据set的size进行排序,从小到大（这样计算交集，需要处理的元素更少）</span></span><br><span class="line">    <span class="comment">/* Sort sets from the smallest to largest, this will improve our</span></span><br><span class="line"><span class="comment">     * algorithm's performance */</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据dstkey判断是否需要将得到的交集保存(SINTER/SINTERSTORE)</span></span><br><span class="line">    <span class="comment">/* The first thing we should output is the total number of elements...</span></span><br><span class="line"><span class="comment">     * since this is a multi-bulk write, but at this stage we don't know</span></span><br><span class="line"><span class="comment">     * the intersection set size, so we use a trick, append an empty object</span></span><br><span class="line"><span class="comment">     * to the output list and save the pointer to later modify it with the</span></span><br><span class="line"><span class="comment">     * right length */</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with an empty set inside */</span></span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Iterate all the elements of the first (smallest) set, and test</span></span><br><span class="line"><span class="comment">     * the element against all the other sets, if at least one set does</span></span><br><span class="line"><span class="comment">     * not include the element it is discarded */</span></span><br><span class="line">    <span class="comment">// 获取最小的set的迭代器si</span></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;elesds,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 迭代si,并判断si中的每个元素,是否在其他集合中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="comment">/* intset with intset is simple... and fast */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* in order to compare an integer with an object we</span></span><br><span class="line"><span class="comment">                 * have to use the generic function, creating an object</span></span><br><span class="line"><span class="comment">                 * for this */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                        sdsfree(elesds);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!setTypeIsMember(sets[j],elesds)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only take action when all sets contain the member */</span></span><br><span class="line">        <span class="comment">// 当si的一个元素,在sets[]中都遍历了,并且存在,则向客户端返回改元素or加入到指定的dstkey中</span></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT)</span><br><span class="line">                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                    elesds = sdsfromlonglong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                    sdsfree(elesds);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,elesds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="comment">/* Store the resulting set into the target, if the intersection</span></span><br><span class="line"><span class="comment">         * is not an empty set. */</span></span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当dstset是有值的,保存到db中</span></span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"sinterstore"</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredMultiBulkLength(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SINTERSTORE命令"><a href="#SINTERSTORE命令" class="headerlink" title="SINTERSTORE命令"></a><code>SINTERSTORE</code>命令</h3><p>这个命令类似于 <code>SINTER</code> 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
<p><code>destination</code> 可以是 <code>key</code> 本身。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>，写命令，并可能导致内存使用增加。</li>
</ul>
<h4 id="命令形式-42"><a href="#命令形式-42" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTERSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-42"><a href="#内部实现函数-42" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体参考<code>SINTER</code>命令。</p>
<h3 id="SUNION命令"><a href="#SUNION命令" class="headerlink" title="SUNION命令"></a><code>SUNION</code>命令</h3><p>返回一个集合的全部成员，该集合是所有给定集合的并集。</p>
<p>不存在的 <code>key</code> 被视为空集。</p>
<ul>
<li><code>sflags</code>：<code>rS</code>,读命令，具有幂等性。</li>
</ul>
<h4 id="命令形式-43"><a href="#命令形式-43" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-43"><a href="#内部实现函数-43" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>对于<code>SUNION</code>,<code>SUNIONSTORE</code>,<code>SDIFF</code>,<code>SDIFFSTORE</code>其实是公用一个函数<code>sunionDiffGenericCommand()</code>实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="comment">// sunionCommand() -&gt; sunionDiffGenericCommand()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionDiffGenericCommand</span><span class="params">(client *c, robj **setkeys, <span class="keyword">int</span> setnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                              robj *dstkey, <span class="keyword">int</span> op)</span> </span>&#123;</span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的Set key是否存在和类型是否正确,并将其保存到set[]中(不存在的key,会在对应位置保存NULL指针)</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这段函数，是用来选择SDIFF的计算方式的:</span></span><br><span class="line">    <span class="comment">// 方式1:</span></span><br><span class="line">    <span class="comment">//    * 选取第一个Set, 然后迭代set[0]的元素, 在set[j](0&lt;j&lt;setnum)中查找是否存在，如果均不存在,则保存到dstkey中</span></span><br><span class="line">    <span class="comment">//    * 时间复杂度是O(N*M), N是set[0]的size, M是剩余set的总size</span></span><br><span class="line">    <span class="comment">// 方式2:</span></span><br><span class="line">    <span class="comment">//    * 将第一个set的所有元素添加到一个临时的set中，然后在迭代后面set[j](0&lt;j&lt;setnum)中,并尝试将元素从临时set中删除</span></span><br><span class="line">    <span class="comment">//    * 时间复杂度是O(N) N是所有set的总size</span></span><br><span class="line">    <span class="comment">/* Select what DIFF algorithm to use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Algorithm 1 is O(N*M) where N is the size of the element first set</span></span><br><span class="line"><span class="comment">     * and M the total number of sets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Algorithm 2 is O(N) where N is the total number of elements in all</span></span><br><span class="line"><span class="comment">     * the sets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We compute what is the best bet with the current input here. */</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Algorithm 1 has better constant times and performs less operations</span></span><br><span class="line"><span class="comment">         * if there are elements in common. Give it some advantage. */</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* With algorithm 1 it is better to order the sets to subtract</span></span><br><span class="line"><span class="comment">             * by decreasing size, so that we are more likely to find</span></span><br><span class="line"><span class="comment">             * duplicated elements ASAP. */</span></span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来保存临时数组等的set</span></span><br><span class="line">    <span class="comment">/* We need a temp set object to store our union. If the dstkey</span></span><br><span class="line"><span class="comment">     * is not NULL (that is, we are inside an SUNIONSTORE operation) then</span></span><br><span class="line"><span class="comment">     * this set object will be the resulting object to set into the target key*/</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">// UNION是最简单的，只要遍历所有元素，存到dstset就可以了</span></span><br><span class="line">        <span class="comment">/* Union is trivial, just add every element of every set to the</span></span><br><span class="line"><span class="comment">         * temporary set. */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// DIFF的方案1</span></span><br><span class="line">        <span class="comment">/* DIFF Algorithm 1:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We perform the diff by iterating all the elements of the first set,</span></span><br><span class="line"><span class="comment">         * and only adding it to the target set if the element does not exist</span></span><br><span class="line"><span class="comment">         * into all the other sets.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This way we perform at max N*M operations, where N is the size of</span></span><br><span class="line"><span class="comment">         * the first set, and M the number of sets. */</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* There is no other set with this element. Add it. */</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// DIFF的方案2</span></span><br><span class="line">        <span class="comment">/* DIFF Algorithm 2:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Add all the elements of the first set to the auxiliary set.</span></span><br><span class="line"><span class="comment">         * Then remove all the elements of all the next sets from it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is O(N) where N is the sum of all the elements in every</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                sdsfree(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Exit if result set is empty as any additional removal</span></span><br><span class="line"><span class="comment">             * of elements will have no effect. */</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要将结果写到一个dstkey</span></span><br><span class="line">    <span class="comment">/* Output the content of the resulting set, if not in STORE mode */</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        addReplyMultiBulkLen(c,cardinality);</span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            sdsfree(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        decrRefCount(dstset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="keyword">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,</span><br><span class="line">                op == SET_OP_UNION ? <span class="string">"sunionstore"</span> : <span class="string">"sdiffstore"</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SUNIONSTORE命令"><a href="#SUNIONSTORE命令" class="headerlink" title="SUNIONSTORE命令"></a><code>SUNIONSTORE</code>命令</h3><p>这个命令类似于 <code>SUNION</code> 命令，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<p>如果 <code>destination</code> 已经存在，则将其覆盖。</p>
<p><code>destination</code> 可以是 <code>key</code> 本身。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>,写命令，并可能增加内存使用。</li>
</ul>
<h4 id="命令形式-44"><a href="#命令形式-44" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-44"><a href="#内部实现函数-44" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>详细参考<code>SUNION</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunionstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_UNION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDIFF命令"><a href="#SDIFF命令" class="headerlink" title="SDIFF命令"></a><code>SDIFF</code>命令</h3><p>返回一个集合的全部成员，该集合是所有给定集合之间的差集。</p>
<p>不存在的 <code>key</code> 被视为空集。</p>
<ul>
<li><code>sflags</code>：<code>rS</code>,读命令，具有幂等性。</li>
</ul>
<h4 id="命令形式-45"><a href="#命令形式-45" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-45"><a href="#内部实现函数-45" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>详细参考<code>SUNION</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SDIFFSTORE命令"><a href="#SDIFFSTORE命令" class="headerlink" title="SDIFFSTORE命令"></a><code>SDIFFSTORE</code>命令</h3><p>这个命令的作用和 <code>SDIFF</code> 类似，但它将结果保存到 <code>destination</code> 集合，而不是简单地返回结果集。</p>
<p>如果 <code>destination</code> 集合已经存在，则将其覆盖。</p>
<p><code>destination</code> 可以是 <code>key</code> 本身。</p>
<ul>
<li><code>sflags</code>：<code>wm</code>,写命令，并可能增加内存使用。</li>
</ul>
<h4 id="命令形式-46"><a href="#命令形式-46" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-46"><a href="#内部实现函数-46" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>详细参考<code>SUNION</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdiffstoreCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SMEMBERS命令"><a href="#SMEMBERS命令" class="headerlink" title="SMEMBERS命令"></a><code>SMEMBERS</code>命令</h3><p>返回集合 <code>key</code> 中的所有成员。</p>
<p>不存在的 <code>key</code> 被视为空集合。</p>
<ul>
<li><code>sflags</code>：<code>rS</code>,读命令，具有幂等性。</li>
</ul>
<h4 id="命令形式-47"><a href="#命令形式-47" class="headerlink" title="命令形式"></a>命令形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>
<h4 id="内部实现函数-47"><a href="#内部实现函数-47" class="headerlink" title="内部实现函数"></a>内部实现函数</h4><p>其实内部实现是使用<code>SINTER</code>命令相同,都是<code>sinterCommand()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_set.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sinterCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/17/用CGo实现一个Redis布隆过滤器的Module/" rel="next" title="用CGo实现一个Redis布隆过滤器的Module">
                <i class="fa fa-chevron-left"></i> 用CGo实现一个Redis布隆过滤器的Module
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpeg" alt="Ming">
            
              <p class="site-author-name" itemprop="name">Ming</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mingforpc" title="GitHub &rarr; https://github.com/mingforpc" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:jianmingforpc@gmail.com" title="E-Mail &rarr; mailto:jianmingforpc@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#redisCommand结构体"><span class="nav-number">1.</span> <span class="nav-text">redisCommand结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令的执行"><span class="nav-number">2.</span> <span class="nav-text">命令的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MODULE模块化命令"><span class="nav-number">2.1.</span> <span class="nav-text">MODULE模块化命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式"><span class="nav-number">2.1.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数"><span class="nav-number">2.1.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET命令"><span class="nav-number">2.2.</span> <span class="nav-text">GET命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SET命令"><span class="nav-number">2.3.</span> <span class="nav-text">SET命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETNX命令"><span class="nav-number">2.4.</span> <span class="nav-text">SETNX命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETEX命令"><span class="nav-number">2.5.</span> <span class="nav-text">SETEX命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSETEX命令"><span class="nav-number">2.6.</span> <span class="nav-text">PSETEX命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-5"><span class="nav-number">2.6.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#APPEND命令"><span class="nav-number">2.7.</span> <span class="nav-text">APPEND命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-6"><span class="nav-number">2.7.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-6"><span class="nav-number">2.7.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STRLEN命令"><span class="nav-number">2.8.</span> <span class="nav-text">STRLEN命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-7"><span class="nav-number">2.8.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-7"><span class="nav-number">2.8.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DEL命令"><span class="nav-number">2.9.</span> <span class="nav-text">DEL命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-8"><span class="nav-number">2.9.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-8"><span class="nav-number">2.9.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXISTS命令"><span class="nav-number">2.10.</span> <span class="nav-text">EXISTS命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-9"><span class="nav-number">2.10.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-9"><span class="nav-number">2.10.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETBIT命令"><span class="nav-number">2.11.</span> <span class="nav-text">SETBIT命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-10"><span class="nav-number">2.11.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-10"><span class="nav-number">2.11.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GETBIT命令"><span class="nav-number">2.12.</span> <span class="nav-text">GETBIT命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-11"><span class="nav-number">2.12.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-11"><span class="nav-number">2.12.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BITFIELD命令"><span class="nav-number">2.13.</span> <span class="nav-text">BITFIELD命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-12"><span class="nav-number">2.13.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-12"><span class="nav-number">2.13.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETRANGE命令"><span class="nav-number">2.14.</span> <span class="nav-text">SETRANGE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-13"><span class="nav-number">2.14.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-13"><span class="nav-number">2.14.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GETRANGE命令"><span class="nav-number">2.15.</span> <span class="nav-text">GETRANGE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-14"><span class="nav-number">2.15.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-14"><span class="nav-number">2.15.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUBSTR命令"><span class="nav-number">2.16.</span> <span class="nav-text">SUBSTR命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#INCR命令"><span class="nav-number">2.17.</span> <span class="nav-text">INCR命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-15"><span class="nav-number">2.17.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-15"><span class="nav-number">2.17.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DECR命令"><span class="nav-number">2.18.</span> <span class="nav-text">DECR命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-16"><span class="nav-number">2.18.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-16"><span class="nav-number">2.18.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MGET命令"><span class="nav-number">2.19.</span> <span class="nav-text">MGET命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-17"><span class="nav-number">2.19.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-17"><span class="nav-number">2.19.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPUSH命令"><span class="nav-number">2.20.</span> <span class="nav-text">RPUSH命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-18"><span class="nav-number">2.20.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-18"><span class="nav-number">2.20.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPUSH命令"><span class="nav-number">2.21.</span> <span class="nav-text">LPUSH命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-19"><span class="nav-number">2.21.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-19"><span class="nav-number">2.21.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPUSHX命令"><span class="nav-number">2.22.</span> <span class="nav-text">RPUSHX命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-20"><span class="nav-number">2.22.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-20"><span class="nav-number">2.22.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINSERT命令"><span class="nav-number">2.23.</span> <span class="nav-text">LINSERT命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-21"><span class="nav-number">2.23.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-21"><span class="nav-number">2.23.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPOP命令"><span class="nav-number">2.24.</span> <span class="nav-text">RPOP命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-22"><span class="nav-number">2.24.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-22"><span class="nav-number">2.24.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LPOP命令"><span class="nav-number">2.25.</span> <span class="nav-text">LPOP命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-23"><span class="nav-number">2.25.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-23"><span class="nav-number">2.25.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRPOP命令"><span class="nav-number">2.26.</span> <span class="nav-text">BRPOP命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-24"><span class="nav-number">2.26.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-24"><span class="nav-number">2.26.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BLPOP命令"><span class="nav-number">2.27.</span> <span class="nav-text">BLPOP命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-25"><span class="nav-number">2.27.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-25"><span class="nav-number">2.27.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BRPOPLPUSH命令"><span class="nav-number">2.28.</span> <span class="nav-text">BRPOPLPUSH命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-26"><span class="nav-number">2.28.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-26"><span class="nav-number">2.28.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LLEN命令"><span class="nav-number">2.29.</span> <span class="nav-text">LLEN命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-27"><span class="nav-number">2.29.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-27"><span class="nav-number">2.29.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LINDEX命令"><span class="nav-number">2.30.</span> <span class="nav-text">LINDEX命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-28"><span class="nav-number">2.30.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-28"><span class="nav-number">2.30.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LSET命令"><span class="nav-number">2.31.</span> <span class="nav-text">LSET命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-29"><span class="nav-number">2.31.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-29"><span class="nav-number">2.31.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LRANGE命令"><span class="nav-number">2.32.</span> <span class="nav-text">LRANGE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-30"><span class="nav-number">2.32.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-30"><span class="nav-number">2.32.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LTRIM命令"><span class="nav-number">2.33.</span> <span class="nav-text">LTRIM命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-31"><span class="nav-number">2.33.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-31"><span class="nav-number">2.33.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LREM命令"><span class="nav-number">2.34.</span> <span class="nav-text">LREM命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-32"><span class="nav-number">2.34.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-32"><span class="nav-number">2.34.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPOPLPUSH命令"><span class="nav-number">2.35.</span> <span class="nav-text">RPOPLPUSH命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-33"><span class="nav-number">2.35.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-33"><span class="nav-number">2.35.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SADD命令"><span class="nav-number">2.36.</span> <span class="nav-text">SADD命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-34"><span class="nav-number">2.36.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-34"><span class="nav-number">2.36.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SREM命令"><span class="nav-number">2.37.</span> <span class="nav-text">SREM命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-35"><span class="nav-number">2.37.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-35"><span class="nav-number">2.37.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMOVE命令"><span class="nav-number">2.38.</span> <span class="nav-text">SMOVE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-36"><span class="nav-number">2.38.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-36"><span class="nav-number">2.38.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SISMEMBER命令"><span class="nav-number">2.39.</span> <span class="nav-text">SISMEMBER命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-37"><span class="nav-number">2.39.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-37"><span class="nav-number">2.39.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SCARD命令"><span class="nav-number">2.40.</span> <span class="nav-text">SCARD命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-38"><span class="nav-number">2.40.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-38"><span class="nav-number">2.40.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPOP命令"><span class="nav-number">2.41.</span> <span class="nav-text">SPOP命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-39"><span class="nav-number">2.41.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-39"><span class="nav-number">2.41.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SRANDMEMBER命令"><span class="nav-number">2.42.</span> <span class="nav-text">SRANDMEMBER命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-40"><span class="nav-number">2.42.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-40"><span class="nav-number">2.42.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SINTER命令"><span class="nav-number">2.43.</span> <span class="nav-text">SINTER命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-41"><span class="nav-number">2.43.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-41"><span class="nav-number">2.43.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SINTERSTORE命令"><span class="nav-number">2.44.</span> <span class="nav-text">SINTERSTORE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-42"><span class="nav-number">2.44.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-42"><span class="nav-number">2.44.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUNION命令"><span class="nav-number">2.45.</span> <span class="nav-text">SUNION命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-43"><span class="nav-number">2.45.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-43"><span class="nav-number">2.45.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SUNIONSTORE命令"><span class="nav-number">2.46.</span> <span class="nav-text">SUNIONSTORE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-44"><span class="nav-number">2.46.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-44"><span class="nav-number">2.46.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDIFF命令"><span class="nav-number">2.47.</span> <span class="nav-text">SDIFF命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-45"><span class="nav-number">2.47.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-45"><span class="nav-number">2.47.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDIFFSTORE命令"><span class="nav-number">2.48.</span> <span class="nav-text">SDIFFSTORE命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-46"><span class="nav-number">2.48.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-46"><span class="nav-number">2.48.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMEMBERS命令"><span class="nav-number">2.49.</span> <span class="nav-text">SMEMBERS命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令形式-47"><span class="nav-number">2.49.1.</span> <span class="nav-text">命令形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部实现函数-47"><span class="nav-number">2.49.2.</span> <span class="nav-text">内部实现函数</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ming</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
      
  
  <script type="text/javascript" color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.6.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.6.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.6.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
